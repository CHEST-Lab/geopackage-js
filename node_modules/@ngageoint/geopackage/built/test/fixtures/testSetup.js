"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
var __1 = require("../..");
var geoPackage_1 = require("../../lib/geoPackage");
var geoPackageConnection_1 = require("../../lib/db/geoPackageConnection");
var fs = require('fs-extra'), path = require('path'), crypto = require('crypto'), ImageUtils = require('../../lib/tiles/imageUtils').ImageUtils;
module.exports.createTempName = function () {
    return 'gp_' + crypto.randomBytes(4).readUInt32LE(0) + '.gpkg';
};
module.exports.copyGeopackage = function (orignal) {
    var copy = path.join(__dirname, 'tmp', module.exports.createTempName());
    return new Promise(function (resolve, reject) {
        if (typeof (process) !== 'undefined' && process.version) {
            var fsExtra = require('fs-extra');
            fsExtra.copy(orignal, copy, function (err) {
                resolve(copy);
            });
        }
        else {
            resolve(copy);
        }
    });
};
module.exports.createTmpGeoPackage = function () {
    return __awaiter(this, void 0, void 0, function () {
        var tmpGpPath, geopackage;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tmpGpPath = path.join(__dirname, 'tmp', module.exports.createTempName());
                    return [4 /*yield*/, module.exports.createGeoPackage(tmpGpPath)];
                case 1:
                    geopackage = _a.sent();
                    return [2 /*return*/, {
                            geopackage: geopackage,
                            path: tmpGpPath
                        }];
            }
        });
    });
};
module.exports.createGeoPackage = function (gppath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(typeof (process) !== 'undefined' && process.version)) return [3 /*break*/, 4];
                    return [4 /*yield*/, fs.mkdirp(path.dirname(gppath))];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, fs.open(gppath, 'w')];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, __1.GeoPackage.create(gppath)];
                case 3: return [2 /*return*/, _a.sent()];
                case 4: return [2 /*return*/];
            }
        });
    });
};
module.exports.createBareGeoPackage = function (gppath) {
    return __awaiter(this, void 0, void 0, function () {
        var connection;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(typeof (process) !== 'undefined' && process.version)) return [3 /*break*/, 4];
                    return [4 /*yield*/, fs.mkdirp(path.dirname(gppath))];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, fs.open(gppath, 'w')];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, geoPackageConnection_1.GeoPackageConnection.connect(gppath)];
                case 3:
                    connection = _a.sent();
                    return [2 /*return*/, new geoPackage_1.GeoPackage(path.basename(gppath), gppath, connection)];
                case 4: return [2 /*return*/];
            }
        });
    });
};
module.exports.deleteGeoPackage = function (gppath) {
    return __awaiter(this, void 0, void 0, function () {
        var e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(typeof (process) !== 'undefined' && process.version)) return [3 /*break*/, 4];
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, fs.unlink(gppath)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    e_1 = _a.sent();
                    return [3 /*break*/, 4];
                case 4: return [2 /*return*/];
            }
        });
    });
};
global.loadTile = module.exports.loadTile = function (tilePath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (typeof (process) !== 'undefined' && process.version) {
                return [2 /*return*/, fs.readFile(tilePath)];
            }
            else {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var xhr = new XMLHttpRequest();
                        xhr.open('GET', tilePath, true);
                        xhr.responseType = 'arraybuffer';
                        xhr.onload = function (e) {
                            if (xhr.status !== 200) {
                                return resolve();
                            }
                            return resolve(Buffer.from(this.response));
                        };
                        xhr.onerror = function (e) {
                            reject(e);
                        };
                        xhr.send();
                    })];
            }
            return [2 /*return*/];
        });
    });
};
module.exports.diffImages = function (actualTile, expectedTilePath, callback) {
    module.exports.diffImagesWithDimensions(actualTile, expectedTilePath, 256, 256, callback);
};
module.exports.diffCanvas = function (actualCanvas, expectedTilePath, callback) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (typeof (process) !== 'undefined' && process.version) {
                return [2 /*return*/, ImageUtils.getImage(expectedTilePath).then(function (img) {
                        var Canvas = require('canvas');
                        var expectedCanvas = Canvas.createCanvas(256, 256);
                        expectedCanvas.getContext('2d').drawImage(img, 0, 0);
                        var same = actualCanvas.toDataURL() === expectedCanvas.toDataURL();
                        if (callback) {
                            callback(null, same);
                        }
                        return same;
                    })];
            }
            else {
                module.exports.loadTile(expectedTilePath, function (err, expectedTile) {
                    var expectedBase64 = Buffer.from(expectedTile).toString('base64');
                    var CanvasCompare = require('canvas-compare');
                    CanvasCompare.setImageData(ImageData);
                    CanvasCompare.canvasCompare({
                        baseImageUrl: actualCanvas.toDataURL(),
                        targetImageUrl: 'data:image/png;base64,' + expectedBase64
                    })
                        .then(function (result) {
                        if (callback) {
                            callback(null, true);
                        }
                        return true;
                    })
                        .catch(function (reason) {
                        if (callback) {
                            callback(null, false);
                        }
                        return false;
                    });
                });
            }
            return [2 /*return*/];
        });
    });
};
module.exports.diffCanvasesContexts = function (actualCtx, expectedCtx, width, height) {
    var actualData = actualCtx.getImageData(0, 0, width, height);
    var expectedData = expectedCtx.getImageData(0, 0, width, height);
    if (actualData.data.length != expectedData.data.length)
        return false;
    for (var i = 0; i < actualData.data.length; ++i) {
        if (actualData.data[i] != expectedData.data[i]) {
            return false;
        }
    }
    return true;
};
module.exports.diffImagesWithDimensions = function (actualTile, expectedTilePath, width, height, callback) {
    if (typeof (process) !== 'undefined' && process.version) {
        ImageUtils.getImage(actualTile).then(function (actualImage) {
            var Canvas = require('canvas');
            var actualCanvas = Canvas.createCanvas(width, height);
            var actualCtx = actualCanvas.getContext('2d');
            actualCtx.drawImage(actualImage, 0, 0);
            ImageUtils.getImage(expectedTilePath).then(function (expectedImage) {
                var expectedCanvas = Canvas.createCanvas(width, height);
                var expectedCtx = expectedCanvas.getContext('2d');
                expectedCtx.drawImage(expectedImage, 0, 0);
                if (actualCanvas.toDataURL() !== expectedCanvas.toDataURL()) {
                    console.log('actual');
                    console.log(actualCanvas.toDataURL());
                    console.log('expected');
                    console.log(expectedCanvas.toDataURL());
                }
                callback(null, actualCanvas.toDataURL() === expectedCanvas.toDataURL());
            });
        });
    }
    else {
        if (actualTile instanceof Uint8Array) {
            var binary = '';
            var bytes = actualTile;
            var len = bytes.byteLength;
            for (var i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            actualTile = 'data:image/png;base64,' + btoa(binary);
        }
        var actual = document.createElement('canvas');
        actual.width = width;
        actual.height = height;
        var ctx = actual.getContext('2d');
        ctx.clearRect(0, 0, actual.width, actual.height);
        var image = new Image();
        image.onload = function () {
            ctx.drawImage(image, 0, 0);
            module.exports.loadTile(expectedTilePath, function (err, expectedTile) {
                var expectedBase64 = Buffer.from(expectedTile).toString('base64');
                var expected = document.createElement('canvas');
                expected.width = width;
                expected.height = height;
                var ctx2 = expected.getContext('2d');
                ctx2.clearRect(0, 0, actual.width, actual.height);
                var image2 = new Image();
                image2.onload = function () {
                    ctx2.drawImage(image2, 0, 0);
                    var equal = module.exports.diffCanvasesContexts(ctx, ctx2, width, height);
                    if (!equal) {
                        var h1Tags = document.getElementsByTagName('h1');
                        var h2Tags = document.getElementsByTagName('li');
                        var currentTag;
                        if (h2Tags.length === 0) {
                            currentTag = h1Tags.item(h1Tags.length - 1);
                        }
                        else {
                            currentTag = h2Tags.item(h2Tags.length - 1).parentNode;
                        }
                        var div = document.createElement('div');
                        var span1 = document.createElement('span');
                        span1.style.width = width + 'px';
                        span1.style.display = 'inline-block';
                        span1.innerHTML = 'Actual';
                        var span2 = document.createElement('span');
                        span2.style.width = width + 'px';
                        span2.style.display = 'inline-block';
                        span2.innerHTML = 'Expected';
                        var span3 = document.createElement('span');
                        span3.style.width = width + 'px';
                        span3.style.display = 'inline-block';
                        span3.innerHTML = 'Diff';
                        div.appendChild(span1);
                        div.appendChild(span2);
                        div.appendChild(span3);
                        currentTag.appendChild(div);
                        currentTag.appendChild(actual);
                        currentTag.appendChild(expected);
                        var CanvasCompare = require('canvas-compare');
                        CanvasCompare.setImageData(ImageData);
                        CanvasCompare.canvasCompare({
                            baseImageUrl: actual.toDataURL(),
                            targetImageUrl: expected.toDataURL()
                        })
                            .then(function (result) {
                            currentTag.appendChild(result.producePreview());
                            callback(null, true);
                        })
                            .catch(function (reason) {
                            callback(null, false);
                        });
                    }
                    else {
                        callback(null, equal);
                    }
                };
                image2.src = 'data:image/png;base64,' + expectedBase64;
            });
        };
        image.src = actualTile;
    }
};
exports.default = module.exports;
//# sourceMappingURL=testSetup.js.map