"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var testSetup_1 = __importDefault(require("../../../fixtures/testSetup"));
var relatedTables_1 = require("../../../../lib/extension/relatedTables");
var Verification = require('../../../fixtures/verification'), UserMappingTable = require('../../../../lib/extension/relatedTables/userMappingTable').UserMappingTable, SetupFeatureTable = require('../../../fixtures/setupFeatureTable')
// , testSetup = require('../../../fixtures/testSetup')
, RelatedTablesUtils = require('./relatedTablesUtils'), should = require('chai').should(), wkx = require('wkx'), path = require('path');
describe('Related Tables tests', function () {
    describe('Related Tables Read Tests', function () {
        var testGeoPackage;
        var testPath = path.join(__dirname, '..', '..', '..', 'fixtures', 'tmp');
        var geopackage;
        var geoPackage;
        var filename;
        beforeEach('create the GeoPackage connection', function () {
            return __awaiter(this, void 0, void 0, function () {
                var originalFilename, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'rte.gpkg');
                            return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                        case 1:
                            result = _a.sent();
                            filename = result.path;
                            geoPackage = result.geopackage;
                            return [2 /*return*/];
                    }
                });
            });
        });
        afterEach('close the geopackage connection', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            geoPackage.close();
                            return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should read a relationship', function () {
            var rte = new relatedTables_1.RelatedTablesExtension(geoPackage);
            rte.has().should.be.equal(true);
            var relationships = rte.getRelationships();
            relationships.length.should.be.equal(1);
            for (var i = 0; i < relationships.length; i++) {
                var relationship = relationships[i];
                var baseDao = geoPackage.getFeatureDao(relationship.base_table_name);
                var features = baseDao.queryForAll();
                var baseIdMappings = {};
                for (var f = 0; f < features.length; f++) {
                    var feature = features[f];
                    var row = baseDao.getRow(feature);
                    var relatedIds = rte.getMappingsForBase(relationship.mapping_table_name, row.getId());
                    if (row.getId() === 1) {
                        relatedIds.length.should.be.equal(2);
                    }
                    else if (row.getId() === 2) {
                        relatedIds.length.should.be.equal(1);
                    }
                    baseIdMappings[row.getId()] = relatedIds;
                }
                var relatedIdMappings = {};
                var relatedDao = geoPackage.getAttributeDaoWithTableName(relationship.related_table_name);
                var attributes = relatedDao.queryForAll();
                for (var a = 0; a < attributes.length; a++) {
                    var attribute = attributes[a];
                    var row = relatedDao.getRow(attribute);
                    var baseIds = rte.getMappingsForRelated(relationship.mapping_table_name, row.getId());
                    if (row.getId() === 17) {
                        baseIds.length.should.be.equal(2);
                    }
                    else if (row.getId() === 18) {
                        baseIds.length.should.be.equal(3);
                    }
                    else if (row.getId() === 19) {
                        baseIds.length.should.be.equal(1);
                    }
                    relatedIdMappings[row.getId()] = baseIds;
                }
                for (var baseId in baseIdMappings) {
                    relatedIds = baseIdMappings[baseId.toString()];
                    for (var r = 0; r < relatedIds.length; r++) {
                        var relatedId = relatedIds[r];
                        relatedIdMappings[relatedId.toString()].indexOf(Number(baseId)).should.not.equal(-1);
                    }
                }
                for (var relatedIdMapping in relatedIdMappings) {
                    baseIds = relatedIdMappings[relatedIdMapping.toString()];
                    for (var b = 0; b < baseIds.length; b++) {
                        var baseIdMapping = baseIds[b];
                        baseIdMappings[baseIdMapping.toString()].indexOf(Number(relatedIdMapping)).should.not.equal(-1);
                    }
                }
            }
        });
        it('should get relationships for the base table name', function () {
            var rte = new relatedTables_1.RelatedTablesExtension(geoPackage);
            var relationships = rte.getRelationships('cats_feature');
            relationships.length.should.be.equal(1);
            relationships[0].base_table_name.should.be.equal('cats_feature');
            relationships[0].base_primary_column.should.be.equal('id');
            relationships[0].related_table_name.should.be.equal('cats_media');
            relationships[0].related_primary_column.should.be.equal('id');
        });
        it('should get relationships for the base table name and baseId', function () {
            var rte = new relatedTables_1.RelatedTablesExtension(geoPackage);
            var relationships = rte.getRelatedRows('cats_feature', 1);
            relationships.length.should.be.equal(1);
            relationships[0].related_table_name.should.be.equal('cats_media');
            relationships[0].mappingRows.length.should.be.equal(2);
            relationships[0].mappingRows[0].row.id.should.be.equal(relationships[0].mappingRows[0].getRelatedId());
        });
    });
    describe('Related Tables Write Tests', function () {
        var testGeoPackage;
        var testPath = path.join(__dirname, '..', '..', '..', 'fixtures', 'tmp');
        var geopackage;
        var geoPackage;
        var filename;
        beforeEach('create the GeoPackage connection', function () {
            return __awaiter(this, void 0, void 0, function () {
                var originalFilename, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'gdal_sample.gpkg');
                            return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                        case 1:
                            result = _a.sent();
                            filename = result.path;
                            geoPackage = result.geopackage;
                            return [2 /*return*/];
                    }
                });
            });
        });
        afterEach('close the geopackage connection', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            geoPackage.close();
                            return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should write a relationship', function () {
            var rte = new relatedTables_1.RelatedTablesExtension(geoPackage);
            rte.has().should.be.equal(false);
            var extendedRelationships = rte.getRelationships();
            extendedRelationships.length.should.be.equal(0);
            var baseTableName = 'geometry2d';
            var relatedTableName = 'geometry3d';
            var mappingTableName = 'g2d_3d';
            var additionalColumns = RelatedTablesUtils.createAdditionalUserColumns(UserMappingTable.numRequiredColumns());
            var userMappingTable = UserMappingTable.create(mappingTableName, additionalColumns);
            rte.has(userMappingTable.table_name).should.be.equal(false);
            var numColumns = UserMappingTable.numRequiredColumns() + additionalColumns.length;
            numColumns.should.be.equal(userMappingTable.columns.length);
            var baseIdColumn = userMappingTable.getBaseIdColumn();
            should.exist(baseIdColumn);
            baseIdColumn.name.should.be.equal(UserMappingTable.COLUMN_BASE_ID);
            baseIdColumn.notNull.should.be.equal(true);
            baseIdColumn.primaryKey.should.be.equal(false);
            var featureRelationship = relatedTables_1.RelatedTablesExtension.RelationshipBuilder()
                .setBaseTableName(baseTableName)
                .setRelatedTableName(relatedTableName)
                .setUserMappingTable(userMappingTable);
            return rte.addFeaturesRelationship(featureRelationship)
                .then(function (extendedRelation) {
                rte.has().should.be.equal(true);
                rte.has(userMappingTable.table_name).should.be.equal(true);
                should.exist(extendedRelation);
                var relationships = rte.getRelationships();
                relationships.length.should.be.equal(1);
                geoPackage.isTable(mappingTableName).should.be.equal(true);
                var baseDao = geoPackage.getFeatureDao(baseTableName);
                var relatedDao = geoPackage.getFeatureDao(relatedTableName);
                var baseResults = baseDao.queryForAll();
                var relatedResults = relatedDao.queryForAll();
                var userMappingDao = rte.getMappingDao(mappingTableName);
                var userMappingRow;
                for (var i = 0; i < 10; i++) {
                    userMappingRow = userMappingDao.newRow();
                    userMappingRow.setBaseId(Math.floor(Math.random() * baseResults.length));
                    userMappingRow.setRelatedId(Math.floor(Math.random() * relatedResults.length));
                    RelatedTablesUtils.populateRow(userMappingTable, userMappingRow, UserMappingTable.requiredColumns());
                    var result = userMappingDao.create(userMappingRow);
                }
                var count = userMappingDao.getCount();
                count.should.be.equal(10);
                userMappingTable = userMappingDao.table;
                var columns = userMappingTable.columnNames;
                var userMappingRows = userMappingDao.queryForAll();
                userMappingRows.length.should.be.equal(10);
                var rowsDeleted = 0;
                for (var i = 0; i < userMappingRows.length; i++) {
                    var resultRow = userMappingDao.getUserMappingRow(userMappingRows[i]);
                    should.not.exist(resultRow.getId());
                    RelatedTablesUtils.validateUserRow(columns, resultRow);
                    RelatedTablesUtils.validateDublinCoreColumns(resultRow);
                    var deleteResult = userMappingDao.deleteByIds(resultRow.getBaseId(), resultRow.getRelatedId());
                    rowsDeleted += deleteResult;
                }
                rowsDeleted.should.be.equal(10);
                rte.removeRelationship(extendedRelation);
                rte.has(userMappingTable.table_name).should.be.equal(false);
                relationships = rte.getRelationships();
                relationships.length.should.be.equal(0);
                geoPackage.isTable(mappingTableName).should.be.equal(false);
                rte.removeExtension();
                rte.has().should.be.equal(false);
            })
                .catch(function (error) {
                console.log('error', error);
                false.should.be.equal(true);
            });
        });
    });
});
//# sourceMappingURL=testRelatedTables.js.map