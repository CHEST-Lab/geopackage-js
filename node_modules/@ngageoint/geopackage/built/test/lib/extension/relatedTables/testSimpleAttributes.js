"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var testSetup_1 = __importDefault(require("../../../fixtures/testSetup"));
var relatedTables_1 = require("../../../../lib/extension/relatedTables");
var DataType = require('../../../../lib/db/dataTypes').DataTypes, Verification = require('../../../fixtures/verification'), ContentsDao = require('../../../../lib/core/contents/contentsDao').ContentsDao, UserMappingTable = require('../../../../lib/extension/relatedTables/userMappingTable').UserMappingTable, SimpleAttributesTable = require('../../../../lib/extension/relatedTables/simpleAttributesTable').SimpleAttributesTable
// , testSetup = require('../../../fixtures/testSetup')
, RelatedTablesUtils = require('./relatedTablesUtils'), should = require('chai').should(), wkx = require('wkx'), path = require('path');
describe('Related Simple Attributes tests', function () {
    var testGeoPackage;
    var testPath = path.join(__dirname, '..', '..', '..', 'fixtures', 'tmp');
    var geoPackage;
    var tileBuffer;
    var filename;
    beforeEach('create the GeoPackage connection', function () {
        return __awaiter(this, void 0, void 0, function () {
            var originalFilename, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'attributes.gpkg');
                        return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                    case 1:
                        result = _a.sent();
                        filename = result.path;
                        geoPackage = result.geopackage;
                        return [4 /*yield*/, loadTile(path.join(__dirname, '..', '..', '..', 'fixtures', 'tiles', '0', '0', '0.png'))];
                    case 2:
                        // @ts-ignore
                        tileBuffer = _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach('delete the geopackage', function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        geoPackage.close();
                        return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    function validateContents(simpleAttributesTable, contents) {
        should.exist(contents);
        should.exist(contents.data_type);
        SimpleAttributesTable.RELATION_TYPE.dataType.should.be.equal(contents.data_type);
        simpleAttributesTable.table_name.should.be.equal(contents.table_name);
        should.exist(contents.last_change);
    }
    it('should create a simple attributes relationship', function () {
        var rte = new relatedTables_1.RelatedTablesExtension(geoPackage);
        rte.has().should.be.equal(false);
        var extendedRelationships = rte.getRelationships();
        extendedRelationships.length.should.be.equal(0);
        var attributesTables = geoPackage.getAttributesTables();
        var baseTableName = geoPackage.getAttributesTables()[0];
        // Validate nullable non simple columns
        try {
            SimpleAttributesTable.create('simple_table', RelatedTablesUtils.createAdditionalUserColumns(SimpleAttributesTable.numRequiredColumns(), false));
            should.fail('Simple Attributes Table', undefined, 'Simple Attributes Table created with nullable non simple columns');
        }
        catch (error) {
            // pass
        }
        // Validate non nullable non simple columns
        try {
            SimpleAttributesTable.create('simple_table', RelatedTablesUtils.createAdditionalUserColumns(SimpleAttributesTable.numRequiredColumns(), true));
            should.fail('Simple Attributes Table', undefined, 'Simple Attributes Table created with non nullable non simple columns');
        }
        catch (error) {
            // pass
        }
        // Validate nullable simple columns
        try {
            SimpleAttributesTable.create('simple_table', RelatedTablesUtils.createSimpleUserColumns(SimpleAttributesTable.numRequiredColumns(), false));
            should.fail('Simple Attributes Table', undefined, 'Simple Attributes Table created with nullable simple columns');
        }
        catch (error) {
            // pass
        }
        // Populate and validate a simple attribute table
        var simpleUserColumns = RelatedTablesUtils.createSimpleUserColumns(SimpleAttributesTable.numRequiredColumns(), true);
        var simpleTable = SimpleAttributesTable.create('simple_table', simpleUserColumns);
        var simpleColumns = simpleTable.columnNames;
        simpleColumns.length.should.be.equal(SimpleAttributesTable.numRequiredColumns() + simpleUserColumns.length);
        var idColumn = simpleTable.getIdColumn();
        should.exist(idColumn);
        idColumn.name.should.be.equal(SimpleAttributesTable.COLUMN_ID);
        idColumn.dataType.should.be.equal(DataType.INTEGER);
        idColumn.notNull.should.be.equal(true);
        idColumn.primaryKey.should.be.equal(true);
        var additionalMappingColumns = RelatedTablesUtils.createAdditionalUserColumns(UserMappingTable.numRequiredColumns());
        var mappingTableName = 'attributes_simple_attributes';
        var userMappingTable = UserMappingTable.create(mappingTableName, additionalMappingColumns);
        rte.has(userMappingTable.table_name).should.be.equal(false);
        userMappingTable.columnNames.length.should.be.equal(UserMappingTable.numRequiredColumns() + additionalMappingColumns.length);
        var baseIdColumn = userMappingTable.getBaseIdColumn();
        should.exist(baseIdColumn);
        baseIdColumn.name.should.be.equal(UserMappingTable.COLUMN_BASE_ID);
        baseIdColumn.dataType.should.be.equal(DataType.INTEGER);
        baseIdColumn.notNull.should.be.equal(true);
        baseIdColumn.primaryKey.should.be.equal(false);
        var relatedIdColumn = userMappingTable.getRelatedIdColumn();
        should.exist(relatedIdColumn);
        relatedIdColumn.name.should.be.equal(UserMappingTable.COLUMN_RELATED_ID);
        relatedIdColumn.dataType.should.be.equal(DataType.INTEGER);
        relatedIdColumn.notNull.should.be.equal(true);
        relatedIdColumn.primaryKey.should.be.equal(false);
        rte.has(userMappingTable.table_name).should.be.equal(false);
        // Create the simple attributes table, content row, and relationship between the
        // attributes table and simple attributes table
        var contentsDao = geoPackage.contentsDao;
        var contentsTables = contentsDao.getTables();
        contentsTables.indexOf(simpleTable.table_name).should.be.equal(-1);
        var relationship = relatedTables_1.RelatedTablesExtension.RelationshipBuilder()
            .setBaseTableName(baseTableName)
            .setRelatedTable(simpleTable)
            .setUserMappingTable(userMappingTable);
        return rte.addSimpleAttributesRelationship(relationship)
            .then(function (extendedRelation) {
            var e_1, _a;
            validateContents(simpleTable, simpleTable.contents);
            rte.has().should.be.equal(true);
            rte.has(userMappingTable.table_name).should.be.equal(true);
            should.exist(extendedRelation);
            var relationships = rte.getRelationships();
            relationships.length.should.be.equal(1);
            geoPackage.isTable(mappingTableName).should.be.equal(true);
            geoPackage.isTable(simpleTable.table_name).should.be.equal(true);
            contentsDao.getTables().indexOf(simpleTable.table_name).should.not.be.equal(-1);
            validateContents(simpleTable, contentsDao.queryForId(simpleTable.table_name));
            SimpleAttributesTable.RELATION_TYPE.dataType.should.be.equal(geoPackage.getTableType(simpleTable.table_name));
            geoPackage.isTableType(SimpleAttributesTable.RELATION_TYPE.dataType, simpleTable.table_name);
            // Validate the simple attributes DAO
            var simpleDao = rte.getSimpleAttributesDao(simpleTable);
            should.exist(simpleDao);
            simpleTable = simpleDao.simpleAttributesTable;
            should.exist(simpleTable);
            validateContents(simpleTable, simpleTable.contents);
            // Insert ismple attributes table rows
            var simpleCount = 2 + Math.floor(Math.random() * 9);
            var simpleRowId = 0;
            for (var i = 0; i < simpleCount - 1; i++) {
                var simpleRow = simpleDao.newRow();
                RelatedTablesUtils.populateRow(simpleTable, simpleRow, SimpleAttributesTable.requiredColumns());
                simpleRowId = simpleDao.create(simpleRow);
                simpleRowId.should.be.greaterThan(0);
            }
            // copy the last row insert and insert the final simple row
            var simpleRowToCopy = simpleDao.queryForId(simpleRowId);
            simpleRowToCopy.resetId();
            var copiedSimpleId = simpleDao.create(simpleRowToCopy);
            copiedSimpleId.should.be.greaterThan(0);
            copiedSimpleId.should.be.equal(simpleRowId + 1);
            simpleCount.should.be.equal(simpleDao.count());
            // Build the Attributes Ids
            var attributesDao = geoPackage.getAttributeDaoWithTableName(baseTableName);
            var allAttributes = attributesDao.queryForAll();
            var attributeIds = [];
            for (var i = 0; i < allAttributes.length; i++) {
                var row_1 = attributesDao.getRow(allAttributes[i]);
                attributeIds.push(row_1.getId());
            }
            var allSimpleAttributes = simpleDao.queryForAll();
            var simpleIds = [];
            for (var i = 0; i < allSimpleAttributes.length; i++) {
                var row_2 = simpleDao.getRow(allSimpleAttributes[i]);
                simpleIds.push(row_2.getId());
            }
            // Insert user mapping rows between feature ids and attribute ids
            var userMappingDao = rte.getMappingDao(mappingTableName);
            for (var i = 0; i < 10; i++) {
                var userMappingRow = userMappingDao.newRow();
                userMappingRow.setBaseId(attributeIds[Math.floor(Math.random() * attributeIds.length)]);
                userMappingRow.setRelatedId(simpleIds[Math.floor(Math.random() * simpleIds.length)]);
                RelatedTablesUtils.populateRow(userMappingTable, userMappingRow, UserMappingTable.requiredColumns());
                var created = userMappingDao.create(userMappingRow);
                created.should.be.greaterThan(0);
            }
            userMappingDao.count().should.be.equal(10);
            // Validate the user mapping rows
            userMappingTable = userMappingDao.getTable();
            var mappingColumns = userMappingTable.columnNames;
            var userMappingRows = userMappingDao.queryForAll();
            var count = userMappingRows.length;
            count.should.be.equal(10);
            var manualCount = 0;
            for (var i = 0; i < count; i++) {
                var umr = userMappingRows[i];
                var row2 = userMappingDao.getUserMappingRow(umr);
                row2.hasId().should.be.equal(false);
                attributeIds.indexOf(row2.getBaseId()).should.be.not.equal(-1);
                simpleIds.indexOf(row2.getRelatedId()).should.be.not.equal(-1);
                RelatedTablesUtils.validateUserRow(mappingColumns, row2);
                RelatedTablesUtils.validateDublinCoreColumns(row2);
                manualCount++;
            }
            manualCount.should.be.equal(count);
            var extendedRelationsDao = rte.extendedRelationDao;
            var attributeBaseTableRelations = extendedRelationsDao.getBaseTableRelations(attributesDao.table_name);
            var attributeTableRelations = extendedRelationsDao.getTableRelations(attributesDao.table_name);
            attributeBaseTableRelations.length.should.be.equal(1);
            attributeTableRelations.length.should.be.equal(1);
            attributeBaseTableRelations[0].id.should.be.equal(attributeTableRelations[0].id);
            extendedRelationsDao.getRelatedTableRelations(attributesDao.table_name).length.should.be.equal(0);
            // Test the attribute table relations
            for (var i = 0; i < attributeBaseTableRelations.length; i++) {
                // Test the relation
                var attributeRelation = attributeBaseTableRelations[i];
                attributeRelation.id.should.be.greaterThan(0);
                attributesDao.table_name.should.be.equal(attributeRelation.base_table_name);
                attributesDao.table.getPkColumn().name.should.be.equal(attributeRelation.base_primary_column);
                simpleDao.table_name.should.be.equal(attributeRelation.related_table_name);
                simpleDao.getTable().getPkColumn().name.should.be.equal(attributeRelation.related_primary_column);
                SimpleAttributesTable.RELATION_TYPE.name.should.be.equal(attributeRelation.relation_name);
                // test the user mappings from the relation
                var userMappingDao = rte.getMappingDao(attributeRelation.mapping_table_name);
                var totalMappedCount = userMappingDao.count();
                var mappings = userMappingDao.queryForAll();
                for (var m = 0; m < mappings.length; m++) {
                    umr = userMappingDao.getUserMappingRow(mappings[i]);
                    attributeIds.indexOf(umr.getBaseId()).should.not.be.equal(-1);
                    simpleIds.indexOf(umr.getRelatedId()).should.not.be.equal(-1);
                    RelatedTablesUtils.validateUserRow(mappingColumns, umr);
                    RelatedTablesUtils.validateDublinCoreColumns(umr);
                }
                // get and test the attributes DAO
                simpleDao = rte.getSimpleAttributesDao(attributeRelation);
                should.exist(simpleDao);
                simpleTable = simpleDao.getTable();
                should.exist(simpleTable);
                validateContents(simpleTable, simpleTable.contents);
                var totalMapped = 0;
                // get and test the Attributes Rows mapped to each Simple Attributes Row
                var attributes = attributesDao.queryForAll();
                for (var f = 0; f < attributes.length; f++) {
                    var attributeRow = attributesDao.getRow(attributes[f]);
                    var mappedIds = rte.getMappingsForBase(attributeRelation, attributeRow.getId());
                    var simpleRows = simpleDao.getRows(mappedIds);
                    simpleRows.length.should.be.equal(mappedIds.length);
                    simpleRows.forEach(function (row) {
                        var simpleRow = simpleDao.getRow(row);
                        simpleRow.hasId().should.be.equal(true);
                        simpleRow.getId().should.be.greaterThan(0);
                        simpleIds.indexOf(simpleRow.getId()).should.not.be.equal(-1);
                        mappedIds.indexOf(simpleRow.getId()).should.not.be.equal(-1);
                        RelatedTablesUtils.validateUserRow(simpleColumns, simpleRow);
                        RelatedTablesUtils.validateSimpleDublinCoreColumns(simpleRow);
                    });
                    totalMapped += mappedIds.length;
                }
                totalMappedCount.should.be.equal(totalMapped);
            }
            // Get the relations starting from the simple attributes table
            var simpleRelatedTableRelations = extendedRelationsDao.getRelatedTableRelations(simpleTable.table_name);
            var simpleTableRelations = extendedRelationsDao.getTableRelations(simpleTable.table_name);
            simpleRelatedTableRelations.length.should.be.equal(1);
            simpleTableRelations.length.should.be.equal(1);
            simpleRelatedTableRelations[0].id.should.be.equal(simpleTableRelations[0].id);
            extendedRelationsDao.getBaseTableRelations(simpleTable.table_name).length.should.be.equal(0);
            // Test the media table relations
            simpleRelatedTableRelations.forEach(function (simpleRelation) {
                // Test the relation
                simpleRelation.id.should.be.greaterThan(0);
                attributesDao.table_name.should.be.equal(simpleRelation.base_table_name);
                attributesDao.table.getPkColumn().name.should.be.equal(simpleRelation.base_primary_column);
                simpleDao.table_name.should.be.equal(simpleRelation.related_table_name);
                simpleDao.getTable().getPkColumn().name.should.be.equal(simpleRelation.related_primary_column);
                SimpleAttributesTable.RELATION_TYPE.name.should.be.equal(simpleRelation.relation_name);
                mappingTableName.should.be.equal(simpleRelation.mapping_table_name);
                // Test the user mappings from the relation
                var userMappingDao = rte.getMappingDao(simpleRelation);
                var totalMappedCount = userMappingDao.count();
                var mappings = userMappingDao.queryForAll();
                var umr;
                mappings.forEach(function (row) {
                    umr = userMappingDao.getUserMappingRow(row);
                    attributeIds.indexOf(umr.getBaseId()).should.not.be.equal(-1);
                    simpleIds.indexOf(umr.getRelatedId()).should.not.be.equal(-1);
                    RelatedTablesUtils.validateUserRow(mappingColumns, umr);
                    RelatedTablesUtils.validateDublinCoreColumns(umr);
                });
                // Get and test the attributes DAO
                attributesDao = geoPackage.getAttributeDaoWithTableName(attributesDao.table_name);
                should.exist(attributesDao);
                var attributeTable = attributesDao.table;
                should.exist(attributeTable);
                var attributeContents = attributesDao.contents;
                should.exist(attributeContents);
                ContentsDao.GPKG_CDT_ATTRIBUTES_NAME.should.be.equal(attributeContents.data_type);
                attributeTable.table_name.should.be.equal(attributeContents.table_name);
                should.exist(attributeContents.last_change);
                var simples = simpleDao.queryForAll();
                var totalMapped = 0;
                simples.forEach(function (row) {
                    var simpleRow = simpleDao.getRow(row);
                    var mappedIds = rte.getMappingsForRelated(simpleRelation.mapping_table_name, simpleRow.getId());
                    mappedIds.forEach(function (mappedId) {
                        var attributeRow = attributesDao.queryForId(mappedId);
                        should.exist(attributeRow);
                        attributeRow.hasId().should.be.equal(true);
                        attributeRow.getId().should.be.greaterThan(0);
                        attributeIds.indexOf(attributeRow.getId()).should.not.equal(-1);
                        mappedIds.indexOf(attributeRow.getId()).should.not.equal(-1);
                    });
                    totalMapped += mappedIds.length;
                });
                totalMapped.should.be.equal(totalMappedCount);
            });
            var baseTables = extendedRelationsDao.getBaseTables();
            baseTables.length.should.be.equal(1);
            baseTables[0].should.be.equal(baseTableName);
            var relatedTables = extendedRelationsDao.getRelatedTables();
            relatedTables.length.should.be.equal(1);
            relatedTables[0].should.be.equal(simpleTable.table_name);
            // Delete a single mapping
            var countOfIds = userMappingDao.countByIds(umr);
            var queryOfIds = userMappingDao.queryByIds(umr);
            var queryCount = 0;
            try {
                for (var queryOfIds_1 = __values(queryOfIds), queryOfIds_1_1 = queryOfIds_1.next(); !queryOfIds_1_1.done; queryOfIds_1_1 = queryOfIds_1.next()) {
                    var row = queryOfIds_1_1.value;
                    queryCount++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (queryOfIds_1_1 && !queryOfIds_1_1.done && (_a = queryOfIds_1.return)) _a.call(queryOfIds_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            queryCount.should.be.equal(countOfIds);
            countOfIds.should.be.equal(userMappingDao.deleteByIds(umr));
            userMappingDao.count().should.be.equal(10 - countOfIds);
            // Delete by base id
            var userMappings = userMappingDao.queryForAll();
            var baseIdQuery = userMappingDao.queryByBaseId(userMappingDao.getUserMappingRow(userMappings[0]));
            var countOfBaseIds = baseIdQuery.length;
            var deleted = userMappingDao.deleteByBaseId(userMappingDao.getUserMappingRow(userMappings[0]));
            deleted.should.be.equal(countOfBaseIds);
            // Delete by related id
            var userMappings = userMappingDao.queryForAll();
            var relatedIdQuery = userMappingDao.queryByRelatedId(userMappingDao.getUserMappingRow(userMappings[0]));
            var countOfRelatedIds = relatedIdQuery.length;
            var deleted = userMappingDao.deleteByRelatedId(userMappingDao.getUserMappingRow(userMappings[0]));
            deleted.should.be.equal(countOfRelatedIds);
            // Delete the relationship and user mapping table
            rte.removeRelationship(extendedRelation);
            rte.has(userMappingTable.table_name).should.be.equal(false);
            var relationships = rte.getRelationships();
            relationships.length.should.be.equal(0);
            geoPackage.isTable(mappingTableName).should.be.equal(false);
            // Delete the media table and contents row
            geoPackage.isTable(simpleTable.table_name);
            should.exist(contentsDao.queryForId(simpleTable.table_name));
            geoPackage.deleteTable(simpleTable.table_name);
            geoPackage.isTable(simpleTable.table_name).should.be.equal(false);
            should.exist(contentsDao.queryForId(simpleTable.table_name));
            // Delete the related tables extension
            rte.removeExtension();
            rte.has().should.be.equal(false);
        });
    });
});
//# sourceMappingURL=testSimpleAttributes.js.map