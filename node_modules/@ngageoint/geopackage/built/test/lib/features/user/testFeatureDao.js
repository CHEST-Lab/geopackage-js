"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("../../../..");
var testSetup_1 = __importDefault(require("../../../fixtures/testSetup"));
// @ts-ignore
// @ts-ignore
var FeatureDao = require('../../../../lib/features/user/featureDao').FeatureDao, FeatureColumn = require('../../../../lib/features/user/featureColumn').FeatureColumn, DataTypes = require('../../../../lib/db/dataTypes').DataTypes
// , GeoPackageAPI = require('../../../../index.js')
, BoundingBox = require('../../../../lib/boundingBox').BoundingBox, GeometryData = require('../../../../lib/geom/geometryData').GeometryData
// , testSetup = require('../../../fixtures/testSetup')
, SetupFeatureTable = require('../../../fixtures/setupFeatureTable'), RelatedTablesUtils = require('../../extension/relatedTables/relatedTablesUtils'), MediaTable = require('../../../../lib/extension/relatedTables/mediaTable').MediaTable, SimpleAttributesTable = require('../../../../lib/extension/relatedTables/simpleAttributesTable').SimpleAttributesTable, wkx = require('wkx')
// @ts-ignore
// @ts-ignore
, fs = require('fs-extra'), helpers = require('@turf/helpers'), path = require('path'), should = require('chai').should();
describe('FeatureDao tests', function () {
    describe('Non indexed test', function () {
        var geoPackage;
        var filename;
        beforeEach('create the GeoPackage connection', function () {
            return __awaiter(this, void 0, void 0, function () {
                var originalFilename, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'rivers.gpkg');
                            return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                        case 1:
                            result = _a.sent();
                            filename = result.path;
                            geoPackage = result.geopackage;
                            return [2 /*return*/];
                    }
                });
            });
        });
        afterEach('close the geopackage connection', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            geoPackage.close();
                            return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should read the geometry', function () {
            var e_1, _a;
            var featureDao = geoPackage.getFeatureDao('FEATURESriversds');
            var each = featureDao.queryForEach();
            // @ts-ignore
            // @ts-ignore
            var srs = featureDao.srs;
            try {
                for (var each_1 = __values(each), each_1_1 = each_1.next(); !each_1_1.done; each_1_1 = each_1.next()) {
                    var row = each_1_1.value;
                    var currentRow = featureDao.getRow(row);
                    var geometry = currentRow.getGeometry();
                    should.exist(geometry);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (each_1_1 && !each_1_1.done && (_a = each_1.return)) _a.call(each_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        it('should query for a row with property_1 equal to Gila', function () {
            var e_2, _a;
            var featureDao = geoPackage.getFeatureDao('FEATURESriversds');
            try {
                for (var _b = __values(featureDao.queryForEach('property_1', 'Gila')), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var row = _c.value;
                    row.property_1.should.be.equal('Gila');
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    });
    describe('Indexed test', function () {
        var geoPackage;
        var featureDao;
        var originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'rivers_indexed.gpkg');
        var filename;
        beforeEach('should open the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                        case 1:
                            result = _a.sent();
                            filename = result.path;
                            geoPackage = result.geopackage;
                            featureDao = geoPackage.getFeatureDao('rivers');
                            return [2 /*return*/];
                    }
                });
            });
        });
        afterEach('should close the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            geoPackage.close();
                            return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should query for indexed geometries', function () {
            var e_3, _a;
            var count = 0;
            var bbox = new BoundingBox(-13189576.119, -13126488.564, 6637372.21, 6607360.178);
            var iterator = featureDao.queryIndexedFeaturesWithWebMercatorBoundingBox(bbox);
            try {
                for (var iterator_1 = __values(iterator), iterator_1_1 = iterator_1.next(); !iterator_1_1.done; iterator_1_1 = iterator_1.next()) {
                    var row = iterator_1_1.value;
                    count++;
                    row.values.property_1.should.be.equal('Columbia');
                    should.exist(row.getValueWithColumnName('geom'));
                    should.exist(row.getValueWithColumnName('id'));
                    should.exist(row.getValueWithColumnName('property_0'));
                    should.exist(row.getValueWithColumnName('property_1'));
                    should.exist(row.getValueWithColumnName('property_2'));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) _a.call(iterator_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            count.should.be.equal(1);
        });
    });
    describe('Query For Shapes', function () {
        var originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'test_shapes_two_points.gpkg');
        var filename;
        beforeEach('should copy the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            filename = path.join(__dirname, '..', '..', '..', 'fixtures', 'tmp', testSetup_1.default.createTempName());
                            return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                        case 1:
                            result = _a.sent();
                            filename = result.path;
                            return [2 /*return*/];
                    }
                });
            });
        });
        afterEach('should close the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should query for GeoJSON features', function () {
            var bb = new BoundingBox(-.4, -.6, 2.4, 2.6);
            __1.GeoPackage.queryForGeoJSONFeaturesInTableFromPath(filename, 'QueryTest', bb)
                .then(function (features) {
                features[0].properties.name.should.be.equal('box1');
            });
        });
        it('should iterate GeoJSON features', function () {
            return __awaiter(this, void 0, void 0, function () {
                var count, bb, iterator, iterator_2, iterator_2_1, feature;
                var e_4, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            count = 0;
                            bb = new BoundingBox(-.4, -.6, 2.4, 2.6);
                            return [4 /*yield*/, __1.GeoPackage.iterateGeoJSONFeatures(filename, 'QueryTest', bb)];
                        case 1:
                            iterator = _b.sent();
                            try {
                                for (iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {
                                    feature = iterator_2_1.value;
                                    feature.properties.name.should.be.equal('box1');
                                    count++;
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                            count.should.be.equal(1);
                            return [2 /*return*/];
                    }
                });
            });
        });
    });
    describe('rivers 2 test', function () {
        var geoPackage;
        var featureDao;
        var originalFilename = path.join(__dirname, '..', '..', '..', 'fixtures', 'rivers2.gpkg');
        var filename;
        beforeEach('should open the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, copyAndOpenGeopackage(originalFilename)];
                        case 1:
                            result = _a.sent();
                            filename = result.path;
                            geoPackage = result.geopackage;
                            featureDao = geoPackage.getFeatureDao('FEATURESriversds');
                            return [2 /*return*/];
                    }
                });
            });
        });
        afterEach('should close the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            geoPackage.close();
                            return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(filename)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should query for rivers and calculate distance from a center point', function () {
            var e_5, _a;
            var pointToLineDistance = require('@turf/point-to-line-distance').default;
            var polygonToLine = require('@turf/polygon-to-line').default;
            var booleanPointInPolygon = require('@turf/boolean-point-in-polygon').default;
            // @ts-ignore
            // @ts-ignore
            var pointDistance = require('@turf/distance').default;
            var bb = new BoundingBox(-179, 0, 0, 80);
            var centerPoint = helpers.point([-105.92193603515625, 34.406906587428736]);
            var iterator = featureDao.queryForGeoJSONIndexedFeaturesWithBoundingBox(bb);
            var foundFeatures = [];
            var closestDistance = 100000000000;
            var closest;
            try {
                for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {
                    var row = iterator_3_1.value;
                    foundFeatures.push(row);
                    var geometry = row.geometry;
                    if (geometry.type == 'Point') {
                        var distance = pointDistance(centerPoint, geometry);
                        if (distance < closestDistance) {
                            closest = row;
                            closestDistance = distance;
                        }
                        else if (distance == closestDistance && closest.type != 'Point') {
                            closest = row;
                            closestDistance = distance;
                        }
                    }
                    else if (geometry.type == 'LineString') {
                        distance = pointToLineDistance(centerPoint, geometry);
                        if (distance < closestDistance) {
                            closest = row;
                            closestDistance = distance;
                        }
                        else if (distance == closestDistance && closest.type != 'Point') {
                            closest = row;
                            closestDistance = distance;
                        }
                    }
                    else if (geometry.type == 'Polygon') {
                        if (booleanPointInPolygon(centerPoint, geometry)) {
                            if (closestDistance != 0) {
                                closest = row;
                                closestDistance = 0;
                            }
                        }
                        else {
                            var line = polygonToLine(geometry);
                            // @ts-ignore
                            var distance = pointToLineDistance(centerPoint, line);
                            if (distance < closestDistance) {
                                closest = row;
                                closestDistance = distance;
                            }
                        }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);
                }
                finally { if (e_5) throw e_5.error; }
            }
            closest.properties.Name.should.be.equal('Rio Grande');
        });
    });
    describe('Query tests', function () {
        var geopackage;
        var queryTestFeatureDao;
        var testPath = path.join(__dirname, '..', '..', '..', 'fixtures', 'tmp');
        var testGeoPackage;
        var tileBuffer;
        afterEach('should delete the geopackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, testSetup_1.default.deleteGeoPackage(testGeoPackage)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        beforeEach('get the tile buffer', function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, loadTile(path.join(__dirname, '..', '..', '..', 'fixtures', 'tiles', '0', '0', '0.png'))];
                        case 1:
                            // @ts-ignore
                            tileBuffer = _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        beforeEach('should create the GeoPackage', function () {
            return __awaiter(this, void 0, void 0, function () {
                var geometryColumns, boundingBox, columns, box1, box2, line, line2, point, point2, createRow, featureDao;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            testGeoPackage = path.join(testPath, testSetup_1.default.createTempName());
                            return [4 /*yield*/, testSetup_1.default.createGeoPackage(testGeoPackage)
                                // @ts-ignore
                            ];
                        case 1:
                            geopackage = _a.sent();
                            geometryColumns = SetupFeatureTable.buildGeometryColumns('QueryTest', 'geom', wkx.Types.wkt.GeometryCollection);
                            boundingBox = new BoundingBox(-180, 180, -80, 80);
                            columns = [];
                            columns.push(FeatureColumn.createPrimaryKeyColumnWithIndexAndName(0, 'id'));
                            // @ts-ignore
                            columns.push(FeatureColumn.createGeometryColumn(1, 'geom', wkx.Types.wkt.Point, false, null));
                            columns.push(FeatureColumn.createColumn(2, 'name', DataTypes.TEXT, false, ""));
                            columns.push(FeatureColumn.createColumn(3, '_feature_id', DataTypes.TEXT, false, ""));
                            columns.push(FeatureColumn.createColumn(4, '_properties_id', DataTypes.TEXT, false, ""));
                            box1 = {
                                "type": "Polygon",
                                "coordinates": [
                                    [
                                        [
                                            -1,
                                            1
                                        ],
                                        [
                                            1,
                                            1
                                        ],
                                        [
                                            1,
                                            3
                                        ],
                                        [
                                            -1,
                                            3
                                        ],
                                        [
                                            -1,
                                            1
                                        ]
                                    ]
                                ]
                            };
                            box2 = {
                                "type": "Polygon",
                                "coordinates": [
                                    [
                                        [
                                            0,
                                            0
                                        ],
                                        [
                                            2,
                                            0
                                        ],
                                        [
                                            2,
                                            2
                                        ],
                                        [
                                            0,
                                            2
                                        ],
                                        [
                                            0,
                                            0
                                        ]
                                    ]
                                ]
                            };
                            line = {
                                "type": "LineString",
                                "coordinates": [
                                    [
                                        2,
                                        3
                                    ],
                                    [
                                        -1,
                                        0
                                    ]
                                ]
                            };
                            line2 = {
                                "type": "Feature",
                                "properties": {},
                                "geometry": {
                                    "type": "LineString",
                                    "coordinates": [
                                        [
                                            2.0,
                                            2.5
                                        ],
                                        [
                                            -0.5,
                                            0
                                        ]
                                    ]
                                }
                            };
                            point = {
                                "type": "Point",
                                "coordinates": [
                                    0.5,
                                    1.5
                                ]
                            };
                            point2 = {
                                "type": "Point",
                                "coordinates": [
                                    1.5,
                                    .5
                                ]
                            };
                            createRow = function (geoJson, name, featureDao) {
                                var srs = featureDao.getSrs();
                                var featureRow = featureDao.newRow();
                                var geometryData = new GeometryData();
                                geometryData.setSrsId(srs.srs_id);
                                var geometry = wkx.Geometry.parseGeoJSON(geoJson);
                                geometryData.setGeometry(geometry);
                                featureRow.setGeometry(geometryData);
                                featureRow.setValueWithColumnName('name', name);
                                featureRow.setValueWithColumnName('_feature_id', name);
                                featureRow.setValueWithColumnName('_properties_id', 'properties' + name);
                                return featureDao.create(featureRow);
                            };
                            // create the features
                            // Two intersecting boxes with a line going through the intersection and a point on the line
                            // ---------- / 3
                            // | 1  ____|/_____
                            // |    |  /|  2  |
                            // |____|_/_|     |
                            //      |/        |
                            //      /_________|
                            //     /
                            return [4 /*yield*/, geopackage.createFeatureTableWithGeometryColumns(geometryColumns, boundingBox, 4326, columns)];
                        case 2:
                            // create the features
                            // Two intersecting boxes with a line going through the intersection and a point on the line
                            // ---------- / 3
                            // | 1  ____|/_____
                            // |    |  /|  2  |
                            // |____|_/_|     |
                            //      |/        |
                            //      /_________|
                            //     /
                            _a.sent();
                            featureDao = geopackage.getFeatureDao('QueryTest');
                            queryTestFeatureDao = featureDao;
                            createRow(box1, 'box1', featureDao);
                            createRow(box2, 'box2', featureDao);
                            createRow(line, 'line', featureDao);
                            createRow(point, 'point', featureDao);
                            createRow(point2, 'point2', featureDao);
                            return [4 /*yield*/, featureDao.featureTableIndex.index()];
                        case 3:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        it('should update a shape', function () {
            var e_6, _a, e_7, _b;
            var line;
            try {
                for (var _c = __values(queryTestFeatureDao.queryForEach('_feature_id', 'line')), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var feature = _d.value;
                    line = queryTestFeatureDao.getRow(feature);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_6) throw e_6.error; }
            }
            line.setValueWithColumnName('name', 'UpdatedLine');
            var newLine;
            queryTestFeatureDao.update(line);
            try {
                for (var _e = __values(queryTestFeatureDao.queryForEach('_feature_id', 'line')), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var feature = _f.value;
                    newLine = queryTestFeatureDao.getRow(feature);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_7) throw e_7.error; }
            }
            newLine.getValueWithColumnName('name').should.be.equal('UpdatedLine');
        });
        it('should count by a field', function () {
            var count = queryTestFeatureDao.count('name', 'line');
            count.should.be.equal(1);
        });
        it('should query for _feature_id', function () {
            // @ts-ignore
            var row = __1.GeoPackage.getFeature(geopackage, 'QueryTest', 'line');
            // @ts-ignore
            row.properties.name.should.be.equal('line');
        });
        it('should query for _properties_id', function () {
            // @ts-ignore
            var row = __1.GeoPackage.getFeature(geopackage, 'QueryTest', 'propertiesline');
            // @ts-ignore
            row.properties.name.should.be.equal('line');
        });
        it('should query for the bounding box', function () {
            var e_8, _a;
            var bb = new BoundingBox(-.4, -.6, 2.4, 2.6);
            var iterator = queryTestFeatureDao.queryForGeoJSONIndexedFeaturesWithBoundingBox(bb);
            try {
                for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {
                    var row = iterator_4_1.value;
                    row.properties.name.should.be.equal('box1');
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
        it('should get features in the bounding box', function () {
            // @ts-ignore
            // @ts-ignore
            var bb = new BoundingBox(-.4, -.6, 2.4, 2.6);
            return __1.GeoPackage.getFeaturesInBoundingBox(geopackage, 'QueryTest', -.4, -.6, 2.4, 2.6)
                .then(function (iterator) {
                var e_9, _a;
                try {
                    for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {
                        var feature = iterator_5_1.value;
                        feature.values.name.should.be.equal('box1');
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
            });
        });
        it('should query for box 1', function () {
            var e_10, _a;
            // var bb = new BoundingBox(minLongitudeOrBoundingBox, maxLongitude, minLatitude, maxLatitude)
            var bb = new BoundingBox(-.4, -.6, 2.4, 2.6);
            var iterator = queryTestFeatureDao.queryIndexedFeaturesWithBoundingBox(bb);
            try {
                for (var iterator_6 = __values(iterator), iterator_6_1 = iterator_6.next(); !iterator_6_1.done; iterator_6_1 = iterator_6.next()) {
                    var row = iterator_6_1.value;
                    row.values.name.should.be.equal('box1');
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (iterator_6_1 && !iterator_6_1.done && (_a = iterator_6.return)) _a.call(iterator_6);
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
        it('should query for box 2', function () {
            var e_11, _a;
            var bb = new BoundingBox(1.1, 1.3, .4, .6);
            var iterator = queryTestFeatureDao.queryIndexedFeaturesWithBoundingBox(bb);
            try {
                for (var iterator_7 = __values(iterator), iterator_7_1 = iterator_7.next(); !iterator_7_1.done; iterator_7_1 = iterator_7.next()) {
                    var row = iterator_7_1.value;
                    row.values.name.should.be.equal('box2');
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (iterator_7_1 && !iterator_7_1.done && (_a = iterator_7.return)) _a.call(iterator_7);
                }
                finally { if (e_11) throw e_11.error; }
            }
            ;
        });
        it('should query for box1, box 2 and line', function () {
            var e_12, _a;
            var bb = new BoundingBox(-.1, .1, .9, 1.1);
            var foundFeatures = [];
            var iterator = queryTestFeatureDao.queryIndexedFeaturesWithBoundingBox(bb);
            try {
                for (var iterator_8 = __values(iterator), iterator_8_1 = iterator_8.next(); !iterator_8_1.done; iterator_8_1 = iterator_8.next()) {
                    var row = iterator_8_1.value;
                    foundFeatures.push(row.values.name);
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (iterator_8_1 && !iterator_8_1.done && (_a = iterator_8.return)) _a.call(iterator_8);
                }
                finally { if (e_12) throw e_12.error; }
            }
            foundFeatures.should.be.deep.equal(['box1', 'box2', 'line']);
        });
        it('should query for box1, box 2, line, and point', function () {
            var e_13, _a;
            var bb = new BoundingBox(.4, .6, 1.4, 1.6);
            var foundFeatures = [];
            var iterator = queryTestFeatureDao.queryIndexedFeaturesWithBoundingBox(bb);
            try {
                for (var iterator_9 = __values(iterator), iterator_9_1 = iterator_9.next(); !iterator_9_1.done; iterator_9_1 = iterator_9.next()) {
                    var row = iterator_9_1.value;
                    foundFeatures.push(row.values.name);
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (iterator_9_1 && !iterator_9_1.done && (_a = iterator_9.return)) _a.call(iterator_9);
                }
                finally { if (e_13) throw e_13.error; }
            }
            foundFeatures.should.be.deep.equal(['box1', 'box2', 'line', 'point']);
        });
        it('should query for box1, box 2, line, and point and calculate distance from a center point', function () {
            var e_14, _a;
            var pointToLineDistance = require('@turf/point-to-line-distance').default;
            var polygonToLine = require('@turf/polygon-to-line').default;
            var booleanPointInPolygon = require('@turf/boolean-point-in-polygon').default;
            // @ts-ignore
            // @ts-ignore
            var pointDistance = require('@turf/distance').default;
            // var bb = new BoundingBox(-107.44354248046876, -104.69696044921876, 33.098444531367186, 35.36889537510477);
            var centerPoint = { type: 'Feature',
                properties: {},
                geometry: { type: 'Point',
                    coordinates: [-106.07025146484376, 34.233669953235975] } };
            var bb = new BoundingBox(.4, .6, 1.4, 1.6);
            var centerPoint = {
                "type": "Feature",
                "properties": {},
                "geometry": {
                    "type": "Point",
                    "coordinates": [
                        0.5,
                        1.5
                    ]
                }
            };
            var foundFeatures = [];
            var closestDistance = 100000000000;
            var closest;
            var iterator = queryTestFeatureDao.queryIndexedFeaturesWithBoundingBox(bb);
            try {
                for (var iterator_10 = __values(iterator), iterator_10_1 = iterator_10.next(); !iterator_10_1.done; iterator_10_1 = iterator_10.next()) {
                    var row = iterator_10_1.value;
                    foundFeatures.push(row.values.name);
                    var geometry = row.getGeometry().toGeoJSON();
                    if (geometry.type == 'Point') {
                        var distance = pointDistance(centerPoint, geometry);
                        if (distance < closestDistance) {
                            closest = row;
                            closestDistance = distance;
                        }
                        else if (distance == closestDistance && closest.type != 'Point') {
                            closest = row;
                            closestDistance = distance;
                        }
                    }
                    else if (geometry.type == 'LineString') {
                        // @ts-ignore
                        var distance = pointToLineDistance(centerPoint, geometry);
                        if (distance < closestDistance) {
                            closest = row;
                            closestDistance = distance;
                        }
                        else if (distance == closestDistance && closest.type != 'Point') {
                            closest = row;
                            closestDistance = distance;
                        }
                    }
                    else if (geometry.type == 'Polygon') {
                        // @ts-ignore
                        if (booleanPointInPolygon(centerPoint, geometry)) {
                            if (closestDistance != 0) {
                                closest = row;
                                closestDistance = 0;
                            }
                        }
                        else {
                            var line = polygonToLine(geometry);
                            // @ts-ignore
                            var distance = pointToLineDistance(centerPoint, line);
                            if (distance < closestDistance) {
                                closest = row;
                                closestDistance = distance;
                            }
                        }
                    }
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (iterator_10_1 && !iterator_10_1.done && (_a = iterator_10.return)) _a.call(iterator_10);
                }
                finally { if (e_14) throw e_14.error; }
            }
            closest.values.name.should.be.equal('point');
            foundFeatures.should.be.deep.equal(['box1', 'box2', 'line', 'point']);
        });
        it('should get the x: 1029, y: 1013, z: 11 tile from the GeoPackage api in a reasonable amount of time', function () {
            this.timeout(5000);
            console.time('generating indexed tile');
            return __1.GeoPackage.getFeatureTileFromXYZ(geopackage, 'QueryTest', 1029, 1013, 11, 256, 256)
                .then(function (data) {
                console.timeEnd('generating indexed tile');
                should.exist(data);
            });
        });
        it('should get the x: 1026, y: 1015, z: 11 tile from the GeoPackage api in a reasonable amount of time', function () {
            this.timeout(5000);
            console.time('generating indexed tile');
            return __1.GeoPackage.getFeatureTileFromXYZ(geopackage, 'QueryTest', 1026, 1015, 11, 256, 256)
                .then(function (data) {
                console.timeEnd('generating indexed tile');
                should.exist(data);
            });
        });
        it('should get the x: 64, y: 63, z: 7 features as geojson', function () {
            this.timeout(3000);
            console.time('generating indexed tile');
            return __1.GeoPackage.getGeoJSONFeaturesInTile(geopackage, 'QueryTest', 64, 63, 7)
                .then(function (geoJSON) {
                console.timeEnd('generating indexed tile');
                should.exist(geoJSON);
                geoJSON.length.should.be.equal(5);
            });
        });
        it('should get the x: 64, y: 63, z: 7 tile from the GeoPackage api in a reasonable amount of time', function () {
            this.timeout(3000);
            console.time('generating indexed tile');
            return __1.GeoPackage.getFeatureTileFromXYZ(geopackage, 'QueryTest', 64, 63, 7, 256, 256)
                .then(function (data) {
                console.timeEnd('generating indexed tile');
                should.exist(data);
            });
        });
        it('should create a media relationship between a feature and a media row', function () {
            var rte = geopackage.relatedTablesExtension;
            var additionalMediaColumns = RelatedTablesUtils.createAdditionalUserColumns(MediaTable.numRequiredColumns());
            var mediaTable = MediaTable.create('media_table', additionalMediaColumns);
            rte.createRelatedTable(mediaTable);
            var mediaDao = rte.getMediaDao(mediaTable);
            should.exist(mediaDao);
            mediaTable = mediaDao.mediaTable;
            should.exist(mediaTable);
            // Create media row
            var contentType = 'image/png';
            var mediaRow = mediaDao.newRow();
            mediaRow.setData(tileBuffer);
            mediaRow.setContentType(contentType);
            RelatedTablesUtils.populateRow(mediaTable, mediaRow, MediaTable.requiredColumns());
            var mediaRowId = mediaDao.create(mediaRow);
            mediaRowId.should.be.greaterThan(0);
            mediaRow = mediaDao.queryForId(mediaRowId);
            var featureRow = queryTestFeatureDao.getRow(queryTestFeatureDao.queryForAll()[0]);
            return queryTestFeatureDao.linkMediaRow(featureRow, mediaRow)
                .then(function () {
                var linkedMedia = queryTestFeatureDao.getLinkedMedia(featureRow);
                linkedMedia.length.should.be.equal(1);
                // @ts-ignore
                linkedMedia[0].id.should.be.equal(mediaRowId);
            });
        });
        it('should create a simple attributes relationship between a feature and a simple attributes row', function () {
            var rte = geopackage.relatedTablesExtension;
            var simpleUserColumns = RelatedTablesUtils.createSimpleUserColumns(SimpleAttributesTable.numRequiredColumns(), true);
            var simpleTable = SimpleAttributesTable.create('simple_table', simpleUserColumns);
            rte.createRelatedTable(simpleTable);
            var simpleDao = rte.getSimpleAttributesDao(simpleTable);
            should.exist(simpleDao);
            simpleTable = simpleDao.simpleAttributesTable;
            should.exist(simpleTable);
            // Create simple attributes row
            var simpleRow = simpleDao.newRow();
            RelatedTablesUtils.populateRow(simpleTable, simpleRow, SimpleAttributesTable.requiredColumns());
            var simpleRowId = simpleDao.create(simpleRow);
            simpleRowId.should.be.greaterThan(0);
            simpleRow = simpleDao.queryForId(simpleRowId);
            var featureRow = queryTestFeatureDao.getRow(queryTestFeatureDao.queryForAll()[0]);
            return queryTestFeatureDao.linkSimpleAttributesRow(featureRow, simpleRow)
                .then(function () {
                var linkedAttributes = queryTestFeatureDao.getLinkedSimpleAttributes(featureRow);
                linkedAttributes.length.should.be.equal(1);
                // @ts-ignore
                linkedAttributes[0].id.should.be.equal(simpleRowId);
            });
        });
        it('should create a feature relationship between a feature and another feature row', function () {
            var all = queryTestFeatureDao.queryForAll();
            var featureRow = queryTestFeatureDao.getRow(all[0]);
            var relatedFeatureRow = queryTestFeatureDao.getRow(all[1]);
            return queryTestFeatureDao.linkFeatureRow(featureRow, relatedFeatureRow)
                .then(function () {
                var linkedFeatures = queryTestFeatureDao.getLinkedFeatures(featureRow);
                linkedFeatures.length.should.be.equal(1);
                linkedFeatures[0].id.should.be.equal(relatedFeatureRow.getId());
            });
        });
    });
});
//# sourceMappingURL=testFeatureDao.js.map