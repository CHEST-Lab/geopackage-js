/**
 * @module geoPackage
 */
import { GeoPackageConnection } from './db/geoPackageConnection';
import { RelatedTablesExtension } from './extension/relatedTables';
import { FeatureStyleExtension } from './extension/style/.';
import { ContentsIdExtension } from './extension/contents/.';
import { SpatialReferenceSystemDao } from './core/srs/spatialReferenceSystemDao';
import { GeometryColumnsDao } from './features/columns/geometryColumnsDao';
import { FeatureDao } from './features/user/featureDao';
import { ContentsDao } from './core/contents/contentsDao';
import { TileMatrixSetDao } from './tiles/matrixset/tileMatrixSetDao';
import { TileMatrixDao } from './tiles/matrix/tileMatrixDao';
import { DataColumnsDao } from './dataColumns/dataColumnsDao';
import { DataColumnConstraintsDao } from './dataColumnConstraints/dataColumnConstraintsDao';
import { MetadataDao } from './metadata/metadataDao';
import { MetadataReferenceDao } from './metadata/reference/metadataReferenceDao';
import { ExtensionDao } from './extension/extensionDao';
import { TableIndexDao } from './extension/index/tableIndexDao';
import { GeometryIndexDao } from './extension/index/geometryIndexDao';
import { ExtendedRelationDao } from './extension/relatedTables/extendedRelationDao';
import { AttributeDao } from './attributes/attributeDao';
import { TileDao } from './tiles/user/tileDao';
import { ContentsIdDao } from './extension/contents/contentsIdDao';
import { FeatureTable } from './features/user/featureTable';
import { TileTable } from './tiles/user/tileTable';
import { Contents } from './core/contents/contents';
import { GeometryColumns } from './features/columns/geometryColumns';
import { TableCreator } from './db/tableCreator';
import { BoundingBox } from './boundingBox';
import { TileMatrixSet } from './tiles/matrixset/tileMatrixSet';
import proj4 from 'proj4';
import { UserColumn } from './user/userColumn';
import { DataColumns } from './dataColumns/dataColumns';
import { AttributeRow } from './attributes/attributeRow';
import { SpatialReferenceSystem } from './core/srs/spatialReferenceSystem';
import { Feature } from 'geojson';
import { FeatureRow } from './features/user/featureRow';
/**
 * A `GeoPackage` instance is the interface to a physical GeoPackage SQLite
 * database.
 */
export declare class GeoPackage {
    /** name of the GeoPackage */
    name: string;
    /** path to the GeoPackage */
    path: string;
    connection: GeoPackageConnection;
    tableCreator: TableCreator;
    private _spatialReferenceSystemDao;
    private _contentsDao;
    private _tileMatrixSetDao;
    private _tileMatrixDao;
    private _dataColumnsDao;
    private _extensionDao;
    private _tableIndexDao;
    private _geometryColumnsDao;
    private _dataColumnConstraintsDao;
    private _metadataReferenceDao;
    private _metadataDao;
    private _extendedRelationDao;
    private _contentsIdDao;
    private _contentsIdExtension;
    private _featureStyleExtension;
    private _relatedTablesExtension;
    /**
     * Construct a new GeoPackage object
     * @param name name to give to this GeoPackage
     * @param path path to the GeoPackage
     * @param connection database connection to the GeoPackage
     */
    constructor(name: string, path: string, connection: GeoPackageConnection);
    close(): void;
    get database(): GeoPackageConnection;
    export(): Promise<any>;
    /**
     * @returns {module:core/srs~SpatialReferenceSystemDao} the DAO to access the [SRS table]{@link module:core/srs~SpatialReferenceSystem} in this `GeoPackage`
     */
    get spatialReferenceSystemDao(): SpatialReferenceSystemDao;
    /**
     * @returns {module:core/contents~ContentsDao} the DAO to access the [contents table]{@link module:core/contents~Contents} in this `GeoPackage`
     */
    get contentsDao(): ContentsDao;
    /**
     * @returns {module:tiles/matrixset~TileMatrixSetDao} the DAO to access the [tile matrix set]{@link module:tiles/matrixset~TileMatrixSet} in this `GeoPackage`
     */
    get tileMatrixSetDao(): TileMatrixSetDao;
    /**
     * @returns {module:tiles/matrixset~TileMatrixDao} the DAO to access the [tile matrix]{@link module:tiles/matrixset~TileMatrix} in this `GeoPackage`
     */
    get tileMatrixDao(): TileMatrixDao;
    get dataColumnsDao(): DataColumnsDao;
    get extensionDao(): ExtensionDao;
    get tableIndexDao(): TableIndexDao;
    get geometryColumnsDao(): GeometryColumnsDao;
    get dataColumnConstraintsDao(): DataColumnConstraintsDao;
    get metadataReferenceDao(): MetadataReferenceDao;
    get metadataDao(): MetadataDao;
    get extendedRelationDao(): ExtendedRelationDao;
    get contentsIdDao(): ContentsIdDao;
    get contentsIdExtension(): ContentsIdExtension;
    get featureStyleExtension(): FeatureStyleExtension;
    getGeometryIndexDao(featureDao: FeatureDao<FeatureRow>): GeometryIndexDao;
    get relatedTablesExtension(): RelatedTablesExtension;
    getSrs(srsId: number): SpatialReferenceSystem;
    createRequiredTables(): Promise<GeoPackage>;
    createSupportedExtensions(): GeoPackage;
    /**
     * @returns {module:tiles/user/tileDao~TileDao} the `TileDao` to access [tiles]{@link module:tiles/user/tileTable}
     */
    getTileDaoWithTileMatrixSet(tileMatrixSet: TileMatrixSet): TileDao;
    getTileDaoWithContents(contents: Contents): TileDao;
    getTileDao(tableName: string): TileDao;
    /**
     * Return a hash containing arrays of table names grouped under keys `features`,
     * `tiles`, and `attributes`.
     * @return {{features: string[], tiles: string[], attributes: string[]}}
     */
    getTables(): {
        features: string[];
        tiles: string[];
        attributes: string[];
    };
    getAttributesTables(): string[];
    hasAttributeTable(attributeTableName: string): boolean;
    /**
     *  Get the tile tables
     *  @returns {String[]} tile table names
     */
    getTileTables(): string[];
    /**
     * Checks if the tile table exists in the GeoPackage
     * @param  {String} tileTableName name of the table to query for
     * @returns {Boolean} indicates the existence of the tile table
     */
    hasTileTable(tileTableName: string): boolean;
    /**
     * Checks if the feature table exists in the GeoPackage
     * @param  {String} featureTableName name of the table to query for
     * @returns {Boolean} indicates the existence of the feature table
     */
    hasFeatureTable(featureTableName: string): boolean;
    /**
     *  Get the feature tables
     *  @returns {String[]} feature table names
     */
    getFeatureTables(): string[];
    isTable(tableName: string): boolean;
    isTableType(type: string, tableName: string): boolean;
    getTableType(tableName: string): string;
    getTableContents(tableName: string): Contents;
    deleteTable(tableName: string): boolean;
    getTableCreator(): TableCreator;
    index(): Promise<boolean>;
    indexFeatureTable(table: string, progress?: Function): Promise<boolean>;
    /**
     *  Get a Feature DAO from Geometry Columns
     *
     *  @param {GeometryColumns} geometryColumns Geometry Columns
     *  @returns {FeatureDao}
     */
    getFeatureDaoWithGeometryColumns(geometryColumns: GeometryColumns): FeatureDao<FeatureRow>;
    /**
     * Get a Feature DAO from Contents
     * @param  {Contents}   contents Contents
     *  @returns {FeatureDao}
     */
    getFeatureDaoWithContents(contents: Contents): FeatureDao<FeatureRow>;
    /**
     * Get a Feature DAO from Contents
     * @param  {string}   tableName table name
     *  @returns {FeatureDao}
     */
    getFeatureDao(tableName: string): FeatureDao<FeatureRow>;
    /**
     * Queries for GeoJSON features in a feature table
     * @param  {String}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     * @returns {Object[]} array of GeoJSON features
     */
    queryForGeoJSONFeaturesInTable(tableName: string, boundingBox: BoundingBox): Feature[];
    /**
     * iterates GeoJSON features in a feature table within a bounding box
     * @param  {String}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     * @returns {Iterable<Object>} iterable of GeoJSON features
     */
    iterateGeoJSONFeaturesInTableWithinBoundingBox(tableName: string, boundingBox: BoundingBox): IterableIterator<Feature>;
    /**
     * Create the Geometry Columns table if it does not already exist
     * @returns {Promise}
     */
    createGeometryColumnsTable(): Promise<boolean>;
    /**
     * Get a Attribute DAO
     * @param  {string}   tableName table name
     * @returns {AttributeDao}
     */
    getAttributeDaoWithTableName(tableName: string): AttributeDao<AttributeRow>;
    /**
     * Get a Attribute DAO
     * @param  {Contents}   contents Contents
     * @returns {AttributeDao}
     */
    getAttributeDaoWithContents(contents: Contents): AttributeDao<AttributeRow>;
    createAttributeTable(tableName: string, columns: UserColumn[], dataColumns?: DataColumns[]): Promise<boolean>;
    /**
     * Create the given {@link module:features/user/featureTable~FeatureTable}
     * @param  {FeatureTable}   featureTable    feature table
     */
    createFeatureTable(featureTable: FeatureTable): {
        lastInsertRowid: number;
        changes: number;
    };
    createFeatureTableWithGeometryColumns(geometryColumns: GeometryColumns, boundingBox: BoundingBox, srsId: number, columns?: UserColumn[]): Promise<boolean>;
    createFeatureTableWithGeometryColumnsAndDataColumns(geometryColumns: GeometryColumns, boundingBox: BoundingBox, srsId: number, columns?: UserColumn[], dataColumns?: DataColumns[]): Promise<boolean>;
    /**
     * Create the Tile Matrix Set table if it does not already exist
     * @returns {Promise} resolves when the table is created
     */
    createTileMatrixSetTable(): Promise<boolean>;
    /**
     * Create the Tile Matrix table if it does not already exist
     * @returns {Promise} resolves when the table is created
     */
    createTileMatrixTable(): Promise<boolean>;
    /**
     * Create the given tile table in this GeoPackage.
     *
     * @param  {module:tiles/user/tileTable~TileTable} tileTable
     * @return {object} the result of {@link module:db/geoPackageConnection~GeoPackageConnection#run}
     */
    createTileTable(tileTable: TileTable): {
        lastInsertRowid: number;
        changes: number;
    };
    /**
     * Create a new [tile table]{@link module:tiles/user/tileTable~TileTable} in this GeoPackage.
     *
     * @param {String} tableName tile table name
     * @param {BoundingBox} contentsBoundingBox bounding box of the contents table
     * @param {Number} contentsSrsId srs id of the contents table
     * @param {BoundingBox} tileMatrixSetBoundingBox bounding box of the matrix set
     * @param {Number} tileMatrixSetSrsId srs id of the matrix set
     * @returns {Promise<TileMatrixSet>} `Promise` of the created {@link module:tiles/matrixset~TileMatrixSet}
     */
    createTileTableWithTableName(tableName: string, contentsBoundingBox: BoundingBox, contentsSrsId: number, tileMatrixSetBoundingBox: BoundingBox, tileMatrixSetSrsId: number): Promise<TileMatrixSet>;
    /**
     * Create the tables and rows necessary to store tiles in a {@link module:tiles/matrixset~TileMatrixSet}.
     * This will create a [tile matrix row]{@link module:tiles/matrix~TileMatrix}
     * for every integral zoom level in the range `[minZoom..maxZoom]`.
     *
     * @param {BoundingBox} epsg3857TileBoundingBox
     * @param {TileMatrixSet} tileMatrixSet
     * @param {number} minZoom
     * @param {number} maxZoom
     * @param {number} [tileSize=256] optional tile size in pixels
     * @returns {module:geoPackage~GeoPackage} `this` `GeoPackage`
     */
    createStandardWebMercatorTileMatrix(epsg3857TileBoundingBox: BoundingBox, tileMatrixSet: TileMatrixSet, minZoom: number, maxZoom: number, tileSize?: number): GeoPackage;
    /**
     * Adds a tile to the GeoPackage
     * @param  {object}   tileStream       Byte array or Buffer containing the tile bytes
     * @param  {String}   tableName  Table name to add the tile to
     * @param  {Number}   zoom       zoom level of this tile
     * @param  {Number}   tileRow    row of this tile
     * @param  {Number}   tileColumn column of this tile
     */
    addTile(tileStream: any, tableName: string, zoom: number, tileRow: number, tileColumn: number): number;
    /**
     * Create the Data Columns table if it does not already exist
     */
    createDataColumns(): Promise<boolean>;
    /**
     * Create the Data Column Constraints table if it does not already exist
     */
    createDataColumnConstraintsTable(): Promise<boolean>;
    createMetadataTable(): Promise<boolean>;
    createMetadataReferenceTable(): Promise<boolean>;
    createExtensionTable(): Promise<boolean>;
    createTableIndexTable(): Promise<boolean>;
    createGeometryIndexTable(featureDao: FeatureDao<FeatureRow>): Promise<boolean>;
    createStyleMappingTable(tableName: string, columns?: UserColumn[], dataColumns?: DataColumns[]): Promise<boolean>;
    /**
     * Get the application id of the GeoPackage
     * @returns {string} application id
     */
    getApplicationId(): string;
    getInfoForTable(tableDao: TileDao | FeatureDao<FeatureRow>): any;
    static loadProjections(items: string[]): void;
    static addProjection(name: string, definition: string): void;
    static hasProjection(name: string): proj4.ProjectionDefinition;
}
