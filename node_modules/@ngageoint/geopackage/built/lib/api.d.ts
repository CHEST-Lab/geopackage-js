/// <reference types="node" />
import { GeoPackage } from './geoPackage';
import { FeatureRow } from './features/user/featureRow';
import { UserColumn } from './user/userColumn';
import { SpatialReferenceSystem } from './core/srs/spatialReferenceSystem';
import { DataColumns } from './dataColumns/dataColumns';
import { DataTypes } from './db/dataTypes';
import { GeometryColumns } from './features/columns/geometryColumns';
import { BoundingBox } from './boundingBox';
import { TileMatrixSet } from './tiles/matrixset/tileMatrixSet';
import { FeatureDao } from './features/user/featureDao';
import { SimpleAttributesDao } from './extension/relatedTables/simpleAttributesDao';
import { SimpleAttributesRow } from './extension/relatedTables/simpleAttributesRow';
import { MediaDao } from './extension/relatedTables/mediaDao';
import { MediaRow } from './extension/relatedTables/mediaRow';
import { ExtendedRelation } from './extension/relatedTables/extendedRelation';
import { Feature, FeatureCollection, Point, LineString, Polygon, MultiPolygon } from 'geojson';
import { TileRow } from './tiles/user/tileRow';
import { DBValue } from './db/dbAdapter';
interface ClosestFeature {
    feature_count: number;
    coverage: boolean;
    gp_table: string;
    gp_name: string;
    distance?: number;
}
declare type ColumnMap = {
    [key: string]: {
        index: number;
        name: string;
        max?: number;
        min?: number;
        notNull?: boolean;
        primaryKey?: boolean;
        dataType?: DataTypes;
        displayName: string;
        dataColumn?: DataColumns;
    };
};
/**
 * This module is the entry point to the GeoPackage API, providing static
 * methods for opening and building GeoPackage files.
 */
export declare class GeoPackageAPI {
    static readonly version: string;
    /**
     * In Node, open a GeoPackage file at the given path, or in a browser, load an
     * in-memory GeoPackage from the given byte array.
     * @param  {string|Uint8Array|Buffer} gppathOrByteArray path to the GeoPackage file or `Uint8Array` of GeoPackage bytes
     * @return {Promise<GeoPackage>} promise that resolves with the open {@link module:geoPackage~GeoPackage} object or rejects with an `Error`
     */
    static open(gppathOrByteArray: string | Uint8Array | Buffer): Promise<GeoPackage>;
    /**
     * In Node, create a GeoPackage file at the given file path, or in a browser,
     * create an in-memory GeoPackage.
     * @param  {string} gppath path of the created GeoPackage file; ignored in the browser
     * @return {Promise<typeof GeoPackage>} promise that resolves with the open {@link module:geoPackage~GeoPackage} object or rejects with an  `Error`
     */
    static create(gppath?: string): Promise<GeoPackage>;
    /**
     * Create the [tables and rows](https://www.geopackage.org/spec121/index.html#tiles)
     * necessary to store tiles according to the ubiquitous [XYZ web/slippy-map tiles](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames) scheme.
     * The extent for the [contents table]{@link module:core/contents~Contents} row,
     * `contentsBoundingBox`, is [informational only](https://www.geopackage.org/spec121/index.html#gpkg_contents_cols),
     * and need not match the [tile matrix set]{@link module:tiles/matrixset~TileMatrixSet}
     * extent, `tileMatrixSetBoundingBox`, which should be the precise bounding box
     * used to calculate the tile row and column coordinates of all tiles in the
     * tile set.  The two SRS ID parameters, `contentsSrsId` and `tileMatrixSetSrsId`,
     * must match, however.  See {@link module:tiles/matrixset~TileMatrixSet} for
     * more information about how GeoPackage consumers use the bouding boxes for a
     * tile set.
     *
     * @param {module:geoPackage~GeoPackage} geopackage the GeoPackage that will store the tiles
     * @param {string} tableName the name of the table that will store the tiles
     * @param {BoundingBox} contentsBoundingBox the bounds stored in the [`gpkg_contents`]{@link module:core/contents~Contents} table row for the tile matrix set
     * @param {SRSRef} contentsSrsId the ID of a [spatial reference system]{@link module:core/srs~SpatialReferenceSystem}; must match `tileMatrixSetSrsId`
     * @param {BoundingBox} tileMatrixSetBoundingBox the bounds stored in the [`gpkg_tile_matrix_set`]{@link module:tiles/matrixset~TileMatrixSet} table row
     * @param {SRSRef} tileMatrixSetSrsId the ID of a [spatial reference system]{@link module:core/srs~SpatialReferenceSystem}
     *   for the [tile matrix set](https://www.geopackage.org/spec121/index.html#_tile_matrix_set) table; must match `contentsSrsId`
     * @param {number} minZoom the zoom level of the lowest resolution [tile matrix]{@link module:tiles/matrix~TileMatrix} in the tile matrix set
     * @param {number} maxZoom the zoom level of the highest resolution [tile matrix]{@link module:tiles/matrix~TileMatrix} in the tile matrix set
     * @param tileSize the width and height in pixels of the tile images; defaults to 256
     * @returns {Promise} a `Promise` that resolves with the created {@link module:tiles/matrixset~TileMatrixSet} object, or rejects with an `Error`
     *
     * @todo make `tileMatrixSetSrsId` optional because it always has to be the same anyway
     */
    static createStandardWebMercatorTileTable(geopackage: GeoPackage, tableName: string, contentsBoundingBox: BoundingBox, contentsSrsId: number, tileMatrixSetBoundingBox: BoundingBox, tileMatrixSetSrsId: number, minZoom: number, maxZoom: number, tileSize?: number): Promise<TileMatrixSet>;
    static createFeatureTable(geopackage: GeoPackage, tableName: string, featureColumns?: UserColumn[] | {
        name: string;
        dataType: string;
    }[], geometryColumn?: GeometryColumns, dataColumns?: DataColumns[], boundingBox?: BoundingBox, boundingBoxSrsId?: number): Promise<FeatureDao<FeatureRow>>;
    /**
     * Create a feature table with the properties specified.
     * @param {module:geoPackage~GeoPackage} geopackage the geopackage object
     * @param tableName name of the table to create
     * @param {Object[]} properties properties to create columns from
     * @param {string} properties.name name of the column
     * @param {string} properties.dataType name of the data type
     * @param {DataColumns} [properties.dataColumn] data column for the property
     * @return {Promise}
     */
    static createAttributeTable(geopackage: GeoPackage, tableName: string, properties: {
        name: string;
        dataType: string;
        dataColumn?: {
            table_name: string;
            column_name: string;
            name?: string;
            title?: string;
            description?: string;
            mime_type?: string;
            constraint_name?: string;
        };
    }[]): Promise<boolean>;
    static addAttributeRow(geopackage: GeoPackage, tableName: string, row: unknown): number;
    /**
     * Create a simple attributes table with the properties specified.
     * @param {module:geoPackage~GeoPackage} geopackage the geopackage object
     * @param {Object[]} properties properties to create columns from
     * @param {string} properties.name name of the column
     * @param {string} properties.dataType name of the data type
     * @return {Promise}
     */
    static createSimpleAttributesTable(geopackage: GeoPackage, tableName: string, properties: {
        name: string;
        dataType: string;
    }[]): SimpleAttributesDao<SimpleAttributesRow>;
    /**
     * Create a media table with the properties specified.  These properties are added to the required columns
     * @param {module:geoPackage~GeoPackage} geopackage the geopackage object
     * @param {Object[]} properties properties to create columns from
     * @param {string} properties.name name of the column
     * @param {string} properties.dataType name of the data type
     * @return {Promise}
     */
    static createMediaTable(geopackage: GeoPackage, tableName: string, properties: {
        name: string;
        dataType: string;
        notNull?: boolean;
        defaultValue?: DBValue;
        max?: number;
    }[]): MediaDao<MediaRow>;
    static addMedia(geopackage: GeoPackage, tableName: string, dataBuffer: Buffer, contentType: string, additionalProperties?: {}): number;
    static linkMedia(geopackage: GeoPackage, baseTableName: string, baseId: number, mediaTableName: string, mediaId: number): Promise<number>;
    static getLinkedMedia(geopackage: GeoPackage, baseTableName: string, baseId: number): MediaRow[];
    static getRelatedRows(geopackage: GeoPackage, baseTableName: string, baseId: number): ExtendedRelation[];
    /**
     * Adds a GeoJSON feature to the GeoPackage
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {object}   feature    GeoJSON feature to add
     * @param  {string}   tableName  name of the table that will store the feature
     * @param {boolean} index updates the FeatureTableIndex extension if it exists
     */
    static addGeoJSONFeatureToGeoPackage(geopackage: GeoPackage, feature: Feature, tableName: string, index?: boolean): number;
    /**
     * Queries for GeoJSON features in a feature tables
     * @param  {string}   geoPackagePath  path to the GeoPackage file
     * @param  {string}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     */
    static queryForGeoJSONFeaturesInTableFromPath(geoPackagePath: string, tableName: string, boundingBox: BoundingBox): Promise<Feature[]>;
    /**
     * Queries for GeoJSON features in a feature tables
     * @param  {module:geoPackage~GeoPackage}   geoPackage  open GeoPackage object
     * @param  {string}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     */
    static queryForGeoJSONFeaturesInTable(geoPackage: GeoPackage, tableName: string, boundingBox: BoundingBox): Feature[];
    /**
     * Iterates GeoJSON features in a feature table that matches the bounding box
     * @param  {module:geoPackage~GeoPackage}   geoPackage  open GeoPackage object
     * @param  {string}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     */
    static iterateGeoJSONFeatures(geoPackage: GeoPackage | string, tableName: string, boundingBox: BoundingBox): Promise<IterableIterator<Feature>>;
    static createDataColumnMap(featureDao: FeatureDao<FeatureRow>): ColumnMap;
    /**
     * @typedef {Object} GeoJSONFeatureIterator
     * @property {SpatialReferenceSystem} srs SRS of the iterator
     * @property {FeatureDao} featureDao featureDao of the iterator objects
     * @property {IterableIterator<FeatureRow>} results iterator of results
     */
    /**
     * Iterate GeoJSON features from table
     * @param  {module:geoPackage~GeoPackage} geopackage      open GeoPackage object
     * @param  {string} table           Table name to Iterate
     * @return {GeoJSONFeatureIterator}
     */
    static iterateGeoJSONFeaturesFromTable(geopackage: GeoPackage, table: string): {
        srs: SpatialReferenceSystem;
        featureDao: FeatureDao<FeatureRow>;
        results: IterableIterator<Feature>;
    };
    /**
     * Gets a GeoJSON feature from the table by id
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table to get the feature from
     * @param  {Number}   featureId  ID of the feature
     */
    static getFeature(geopackage: GeoPackage, table: string, featureId: number): Feature;
    static parseFeatureRowIntoGeoJSON(featureRow: FeatureRow, srs: SpatialReferenceSystem, columnMap?: ColumnMap): Feature;
    /**
     * Gets a tile from the specified table
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table to get the tile from
     * @param  {Number}   zoom       zoom level of the tile
     * @param  {Number}   tileRow    row of the tile
     * @param  {Number}   tileColumn column of the tile
     *
     * @todo jsdoc return value
     */
    static getTileFromTable(geopackage: GeoPackage, table: string, zoom: number, tileRow: number, tileColumn: number): TileRow;
    /**
     * Gets the tiles in the EPSG:4326 bounding box
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the tile table
     * @param  {Number}   zoom       Zoom of the tiles to query for
     * @param  {Number}   west       EPSG:4326 western boundary
     * @param  {Number}   east       EPSG:4326 eastern boundary
     * @param  {Number}   south      EPSG:4326 southern boundary
     * @param  {Number}   north      EPSG:4326 northern boundary
     */
    static getTilesInBoundingBox(geopackage: GeoPackage, table: string, zoom: number, west: number, east: number, south: number, north: number): {
        columns: {
            index: number;
            name: string;
            max?: number;
            min?: number;
            notNull?: boolean;
            primaryKey?: boolean;
        }[];
        srs: SpatialReferenceSystem;
        tiles: {
            tableName: string;
            id: number;
            minLongitude: number;
            maxLongitude: number;
            minLatitude: number;
            maxLatitude: number;
            projection: string;
            values: string[];
        }[];
        west: number;
        east: number;
        south: number;
        north: number;
        zoom: number;
    };
    /**
     * Gets the tiles in the EPSG:4326 bounding box
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the tile table
     * @param  {Number}   webZoom       Zoom of the tiles to query for
     * @param  {Number}   west       EPSG:4326 western boundary
     * @param  {Number}   east       EPSG:4326 eastern boundary
     * @param  {Number}   south      EPSG:4326 southern boundary
     * @param  {Number}   north      EPSG:4326 northern boundary
     */
    static getTilesInBoundingBoxWebZoom(geopackage: GeoPackage, table: string, webZoom: number, west: number, east: number, south: number, north: number): {
        columns: {
            index: number;
            name: string;
            max?: number;
            min?: number;
            notNull?: boolean;
            primaryKey?: boolean;
        }[];
        srs: SpatialReferenceSystem;
        tiles: {
            tableName: string;
            id: number;
            minLongitude: number;
            maxLongitude: number;
            minLatitude: number;
            maxLatitude: number;
            projection: string;
            values: string[];
        }[];
        west: number;
        east: number;
        south: number;
        north: number;
        zoom: number;
    };
    static getFeatureTileFromXYZ(geopackage: GeoPackage, table: string, x: number, y: number, z: number, width: number, height: number): Promise<any>;
    static getClosestFeatureInXYZTile(geopackage: GeoPackage, table: string, x: number, y: number, z: number, latitude: number, longitude: number): Feature & ClosestFeature;
    static determineDistance(point: Point, feature: Feature | FeatureCollection): number;
    static determineDistanceFromLine(point: Point, lineString: LineString): number;
    static determineDistanceFromPolygon(point: Point, polygon: Polygon | MultiPolygon): number;
    /**
     * Gets the features in the EPSG:3857 tile
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the feature table
     * @param  {Number}   x       x tile number
     * @param  {Number}   y       y tile number
     * @param  {Number}   z      z tile number
     * @param  {Boolean}   [skipVerification]      skip the extra verification to determine if the feature really is within the tile
     */
    static getGeoJSONFeaturesInTile(geopackage: GeoPackage, table: string, x: number, y: number, z: number, skipVerification?: boolean): Promise<Feature[]>;
    /**
     * Gets the features in the EPSG:4326 bounding box
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the feature table
     * @param  {Number}   west       EPSG:4326 western boundary
     * @param  {Number}   east       EPSG:4326 eastern boundary
     * @param  {Number}   south      EPSG:4326 southern boundary
     * @param  {Number}   north      EPSG:4326 northern boundary
     */
    static getFeaturesInBoundingBox(geopackage: GeoPackage, table: string, west: number, east: number, south: number, north: number): Promise<IterableIterator<FeatureRow>>;
    /**
     * Get the standard 3857 XYZ tile from the GeoPackage.  If a canvas is provided, the tile will be drawn in the canvas
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table containing the tiles
     * @param  {Number}   x          x index of the tile
     * @param  {Number}   y          y index of the tile
     * @param  {Number}   z          zoom level of the tile
     * @param  {Number}   width      width of the resulting tile
     * @param  {Number}   height     height of the resulting tile
     * @param  {any}   canvas     canvas element to draw the tile into
     */
    static xyzTile(geopackage: GeoPackage, table: string, x: number, y: number, z: number, width?: number, height?: number, canvas?: any): Promise<any>;
    /**
     * Draws a tile projected into the specified projection, bounded by the specified by the bounds in EPSG:4326 into the canvas or the image is returned if no canvas is passed in
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table containing the tiles
     * @param  {Number}   minLat     minimum latitude bounds of tile
     * @param  {Number}   minLon     minimum longitude bounds of tile
     * @param  {Number}   maxLat     maximum latitude bounds of tile
     * @param  {Number}   maxLon     maximum longitude bounds of tile
     * @param  {Number}   z          zoom level of the tile
     * @param  {Number}   width      width of the resulting tile
     * @param  {Number}   height     height of the resulting tile
     * @param  {any}   canvas     canvas element to draw the tile into
     */
    static projectedTile(geopackage: GeoPackage, table: string, minLat: number, minLon: number, maxLat: number, maxLon: number, z: number, projection: 'EPSG:4326', width?: number, height?: number, canvas?: any): Promise<any>;
}
export {};
