"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var crsWkt_1 = require("./extension/crsWkt");
var relatedTables_1 = require("./extension/relatedTables");
var _1 = require("./extension/style/.");
var _2 = require("./extension/contents/.");
var spatialReferenceSystemDao_1 = require("./core/srs/spatialReferenceSystemDao");
var geometryColumnsDao_1 = require("./features/columns/geometryColumnsDao");
var featureDao_1 = require("./features/user/featureDao");
var featureTableReader_1 = require("./features/user/featureTableReader");
var contentsDao_1 = require("./core/contents/contentsDao");
var tileMatrixSetDao_1 = require("./tiles/matrixset/tileMatrixSetDao");
var tileMatrixDao_1 = require("./tiles/matrix/tileMatrixDao");
var dataColumnsDao_1 = require("./dataColumns/dataColumnsDao");
var dataColumnConstraintsDao_1 = require("./dataColumnConstraints/dataColumnConstraintsDao");
var metadataDao_1 = require("./metadata/metadataDao");
var metadataReferenceDao_1 = require("./metadata/reference/metadataReferenceDao");
var extensionDao_1 = require("./extension/extensionDao");
var tableIndexDao_1 = require("./extension/index/tableIndexDao");
var geometryIndexDao_1 = require("./extension/index/geometryIndexDao");
var extendedRelationDao_1 = require("./extension/relatedTables/extendedRelationDao");
var attributeDao_1 = require("./attributes/attributeDao");
var tileDao_1 = require("./tiles/user/tileDao");
var contentsIdDao_1 = require("./extension/contents/contentsIdDao");
var attributeTable_1 = require("./attributes/attributeTable");
var tileTableReader_1 = require("./tiles/user/tileTableReader");
var attributeTableReader_1 = require("./attributes/attributeTableReader");
var featureTable_1 = require("./features/user/featureTable");
var styleMappingTable_1 = require("./extension/style/styleMappingTable");
var tileTable_1 = require("./tiles/user/tileTable");
var contents_1 = require("./core/contents/contents");
var dataTypes_1 = require("./db/dataTypes");
var schema_1 = require("./extension/schema");
var tableCreator_1 = require("./db/tableCreator");
var tileMatrix_1 = require("./tiles/matrix/tileMatrix");
var tileBoundingBoxUtils_1 = require("./tiles/tileBoundingBoxUtils");
var tileMatrixSet_1 = require("./tiles/matrixset/tileMatrixSet");
var proj4_1 = __importDefault(require("proj4"));
var defs = __importStar(require("./proj4Defs"));
for (var def in defs) {
    if (defs[def]) {
        proj4_1.default.defs(def, defs[def]);
    }
}
/**
 * A `GeoPackage` instance is the interface to a physical GeoPackage SQLite
 * database.
 */
var GeoPackage = /** @class */ (function () {
    /**
     * Construct a new GeoPackage object
     * @param name name to give to this GeoPackage
     * @param path path to the GeoPackage
     * @param connection database connection to the GeoPackage
     */
    function GeoPackage(name, path, connection) {
        this.name = name;
        this.path = path;
        this.connection = connection;
        this.tableCreator = new tableCreator_1.TableCreator(this);
    }
    GeoPackage.prototype.close = function () {
        this.connection.close();
    };
    Object.defineProperty(GeoPackage.prototype, "database", {
        get: function () {
            return this.connection;
        },
        enumerable: true,
        configurable: true
    });
    GeoPackage.prototype.export = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.connection.export()];
            });
        });
    };
    Object.defineProperty(GeoPackage.prototype, "spatialReferenceSystemDao", {
        /**
         * @returns {module:core/srs~SpatialReferenceSystemDao} the DAO to access the [SRS table]{@link module:core/srs~SpatialReferenceSystem} in this `GeoPackage`
         */
        get: function () {
            return this._spatialReferenceSystemDao || (this._spatialReferenceSystemDao = new spatialReferenceSystemDao_1.SpatialReferenceSystemDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "contentsDao", {
        /**
         * @returns {module:core/contents~ContentsDao} the DAO to access the [contents table]{@link module:core/contents~Contents} in this `GeoPackage`
         */
        get: function () {
            return this._contentsDao || (this._contentsDao = new contentsDao_1.ContentsDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "tileMatrixSetDao", {
        /**
         * @returns {module:tiles/matrixset~TileMatrixSetDao} the DAO to access the [tile matrix set]{@link module:tiles/matrixset~TileMatrixSet} in this `GeoPackage`
         */
        get: function () {
            return this._tileMatrixSetDao || (this._tileMatrixSetDao = new tileMatrixSetDao_1.TileMatrixSetDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "tileMatrixDao", {
        /**
         * @returns {module:tiles/matrixset~TileMatrixDao} the DAO to access the [tile matrix]{@link module:tiles/matrixset~TileMatrix} in this `GeoPackage`
         */
        get: function () {
            return this._tileMatrixDao || (this._tileMatrixDao = new tileMatrixDao_1.TileMatrixDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "dataColumnsDao", {
        get: function () {
            return this._dataColumnsDao || (this._dataColumnsDao = new dataColumnsDao_1.DataColumnsDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "extensionDao", {
        get: function () {
            return this._extensionDao || (this._extensionDao = new extensionDao_1.ExtensionDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "tableIndexDao", {
        get: function () {
            return this._tableIndexDao || (this._tableIndexDao = new tableIndexDao_1.TableIndexDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "geometryColumnsDao", {
        get: function () {
            return this._geometryColumnsDao || (this._geometryColumnsDao = new geometryColumnsDao_1.GeometryColumnsDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "dataColumnConstraintsDao", {
        get: function () {
            return this._dataColumnConstraintsDao || (this._dataColumnConstraintsDao = new dataColumnConstraintsDao_1.DataColumnConstraintsDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "metadataReferenceDao", {
        get: function () {
            return this._metadataReferenceDao || (this._metadataReferenceDao = new metadataReferenceDao_1.MetadataReferenceDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "metadataDao", {
        get: function () {
            return this._metadataDao || (this._metadataDao = new metadataDao_1.MetadataDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "extendedRelationDao", {
        get: function () {
            return this._extendedRelationDao || (this._extendedRelationDao = new extendedRelationDao_1.ExtendedRelationDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "contentsIdDao", {
        get: function () {
            return this._contentsIdDao || (this._contentsIdDao = new contentsIdDao_1.ContentsIdDao(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "contentsIdExtension", {
        get: function () {
            return this._contentsIdExtension || (this._contentsIdExtension = new _2.ContentsIdExtension(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPackage.prototype, "featureStyleExtension", {
        get: function () {
            return this._featureStyleExtension || (this._featureStyleExtension = new _1.FeatureStyleExtension(this));
        },
        enumerable: true,
        configurable: true
    });
    GeoPackage.prototype.getGeometryIndexDao = function (featureDao) {
        return new geometryIndexDao_1.GeometryIndexDao(this, featureDao);
    };
    Object.defineProperty(GeoPackage.prototype, "relatedTablesExtension", {
        get: function () {
            return this._relatedTablesExtension || (this._relatedTablesExtension = new relatedTables_1.RelatedTablesExtension(this));
        },
        enumerable: true,
        configurable: true
    });
    GeoPackage.prototype.getSrs = function (srsId) {
        var dao = this.spatialReferenceSystemDao;
        return dao.queryForId(srsId);
    };
    GeoPackage.prototype.createRequiredTables = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.tableCreator.createRequired()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this];
                }
            });
        });
    };
    GeoPackage.prototype.createSupportedExtensions = function () {
        var crs = new crsWkt_1.CrsWktExtension(this);
        crs.getOrCreateExtension();
        var schema = new schema_1.SchemaExtension(this);
        schema.getOrCreateExtension();
        return this;
    };
    /**
     * @returns {module:tiles/user/tileDao~TileDao} the `TileDao` to access [tiles]{@link module:tiles/user/tileTable}
     */
    GeoPackage.prototype.getTileDaoWithTileMatrixSet = function (tileMatrixSet) {
        var tileMatrices = [];
        var tileMatrixDao = this.tileMatrixDao;
        var results = tileMatrixDao.queryForAllEq(tileMatrixDao_1.TileMatrixDao.COLUMN_TABLE_NAME, tileMatrixSet.table_name, null, null, tileMatrixDao_1.TileMatrixDao.COLUMN_ZOOM_LEVEL +
            ' ASC, ' +
            tileMatrixDao_1.TileMatrixDao.COLUMN_PIXEL_X_SIZE +
            ' DESC, ' +
            tileMatrixDao_1.TileMatrixDao.COLUMN_PIXEL_Y_SIZE +
            ' DESC');
        results.forEach(function (result) {
            var tm = new tileMatrix_1.TileMatrix();
            tileMatrixDao.populateObjectFromResult(tm, result);
            tileMatrices.push(tm);
        });
        var tableReader = new tileTableReader_1.TileTableReader(tileMatrixSet);
        var tileTable = tableReader.readTileTable(this);
        return new tileDao_1.TileDao(this, tileTable, tileMatrixSet, tileMatrices);
    };
    GeoPackage.prototype.getTileDaoWithContents = function (contents) {
        var tileMatrixSet = this.contentsDao.getTileMatrixSet(contents);
        return this.getTileDaoWithTileMatrixSet(tileMatrixSet);
    };
    GeoPackage.prototype.getTileDao = function (tableName) {
        var tms = this.tileMatrixSetDao;
        var results = tms.queryForAllEq(tileMatrixSetDao_1.TileMatrixSetDao.COLUMN_TABLE_NAME, tableName);
        if (results.length > 1) {
            throw new Error('Unexpected state. More than one Tile Matrix Set matched for table name: ' +
                tableName +
                ', count: ' +
                results.length);
        }
        else if (results.length === 0) {
            throw new Error('No Tile Matrix found for table name: ' + tableName);
        }
        var tileMatrixSet = new tileMatrixSet_1.TileMatrixSet();
        tms.populateObjectFromResult(tileMatrixSet, results[0]);
        return this.getTileDaoWithTileMatrixSet(tileMatrixSet);
    };
    /**
     * Return a hash containing arrays of table names grouped under keys `features`,
     * `tiles`, and `attributes`.
     * @return {{features: string[], tiles: string[], attributes: string[]}}
     */
    GeoPackage.prototype.getTables = function () {
        var tables = {
            features: this.getFeatureTables(),
            tiles: this.getTileTables(),
            attributes: this.getAttributesTables(),
        };
        return tables;
    };
    GeoPackage.prototype.getAttributesTables = function () {
        return this.contentsDao.getTables(contentsDao_1.ContentsDao.GPKG_CDT_ATTRIBUTES_NAME);
    };
    GeoPackage.prototype.hasAttributeTable = function (attributeTableName) {
        var tables = this.getAttributesTables();
        return tables && tables.indexOf(attributeTableName) != -1;
    };
    /**
     *  Get the tile tables
     *  @returns {String[]} tile table names
     */
    GeoPackage.prototype.getTileTables = function () {
        var cd = this.contentsDao;
        if (!cd.isTableExists()) {
            return [];
        }
        return cd.getTables(contentsDao_1.ContentsDao.GPKG_CDT_TILES_NAME);
    };
    /**
     * Checks if the tile table exists in the GeoPackage
     * @param  {String} tileTableName name of the table to query for
     * @returns {Boolean} indicates the existence of the tile table
     */
    GeoPackage.prototype.hasTileTable = function (tileTableName) {
        var tables = this.getTileTables();
        return tables && tables.indexOf(tileTableName) !== -1;
    };
    /**
     * Checks if the feature table exists in the GeoPackage
     * @param  {String} featureTableName name of the table to query for
     * @returns {Boolean} indicates the existence of the feature table
     */
    GeoPackage.prototype.hasFeatureTable = function (featureTableName) {
        var tables = this.getFeatureTables();
        return tables && tables.indexOf(featureTableName) != -1;
    };
    /**
     *  Get the feature tables
     *  @returns {String[]} feature table names
     */
    GeoPackage.prototype.getFeatureTables = function () {
        var cd = this.contentsDao;
        if (!cd.isTableExists()) {
            return [];
        }
        return cd.getTables(contentsDao_1.ContentsDao.GPKG_CDT_FEATURES_NAME);
    };
    GeoPackage.prototype.isTable = function (tableName) {
        return !!this.connection.tableExists(tableName);
    };
    GeoPackage.prototype.isTableType = function (type, tableName) {
        return type === this.getTableType(tableName);
    };
    GeoPackage.prototype.getTableType = function (tableName) {
        var contents = this.getTableContents(tableName);
        if (contents) {
            return contents.data_type;
        }
    };
    GeoPackage.prototype.getTableContents = function (tableName) {
        return this.contentsDao.queryForId(tableName);
    };
    GeoPackage.prototype.deleteTable = function (tableName) {
        return this.connection.dropTable(tableName);
    };
    GeoPackage.prototype.getTableCreator = function () {
        return this.tableCreator;
    };
    GeoPackage.prototype.index = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tables, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tables = this.getFeatureTables();
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < tables.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.indexFeatureTable(tables[i])];
                    case 2:
                        if (!(_a.sent())) {
                            throw new Error('Unable to index table ' + tables[i]);
                        }
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, true];
                }
            });
        });
    };
    GeoPackage.prototype.indexFeatureTable = function (table, progress) {
        return __awaiter(this, void 0, void 0, function () {
            var featureDao, fti, tableIndex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        featureDao = this.getFeatureDao(table);
                        fti = featureDao.featureTableIndex;
                        tableIndex = fti.getTableIndex();
                        if (tableIndex) {
                            return [2 /*return*/, true];
                        }
                        return [4 /*yield*/, fti.index(progress)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *  Get a Feature DAO from Geometry Columns
     *
     *  @param {GeometryColumns} geometryColumns Geometry Columns
     *  @returns {FeatureDao}
     */
    GeoPackage.prototype.getFeatureDaoWithGeometryColumns = function (geometryColumns) {
        if (!geometryColumns) {
            throw new Error('Non null Geometry Columns is required to create Feature DAO');
        }
        var tableReader = new featureTableReader_1.FeatureTableReader(geometryColumns);
        var featureTable = tableReader.readFeatureTable(this);
        var dao = new featureDao_1.FeatureDao(this, featureTable, geometryColumns, this.metadataDao);
        return dao;
    };
    /**
     * Get a Feature DAO from Contents
     * @param  {Contents}   contents Contents
     *  @returns {FeatureDao}
     */
    GeoPackage.prototype.getFeatureDaoWithContents = function (contents) {
        var columns = this.contentsDao.getGeometryColumns(contents);
        return this.getFeatureDaoWithGeometryColumns(columns);
    };
    /**
     * Get a Feature DAO from Contents
     * @param  {string}   tableName table name
     *  @returns {FeatureDao}
     */
    GeoPackage.prototype.getFeatureDao = function (tableName) {
        var geometryColumns = this.geometryColumnsDao.queryForTableName(tableName);
        if (!geometryColumns) {
            throw new Error('No Feature Table exists for table name: ' + tableName);
        }
        return this.getFeatureDaoWithGeometryColumns(geometryColumns);
    };
    /**
     * Queries for GeoJSON features in a feature table
     * @param  {String}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     * @returns {Object[]} array of GeoJSON features
     */
    GeoPackage.prototype.queryForGeoJSONFeaturesInTable = function (tableName, boundingBox) {
        var e_1, _a;
        var featureDao = this.getFeatureDao(tableName);
        var features = [];
        var iterator = featureDao.queryForGeoJSONIndexedFeaturesWithBoundingBox(boundingBox);
        try {
            for (var iterator_1 = __values(iterator), iterator_1_1 = iterator_1.next(); !iterator_1_1.done; iterator_1_1 = iterator_1.next()) {
                var feature = iterator_1_1.value;
                features.push(feature);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) _a.call(iterator_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return features;
    };
    /**
     * iterates GeoJSON features in a feature table within a bounding box
     * @param  {String}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     * @returns {Iterable<Object>} iterable of GeoJSON features
     */
    GeoPackage.prototype.iterateGeoJSONFeaturesInTableWithinBoundingBox = function (tableName, boundingBox) {
        var featureDao = this.getFeatureDao(tableName);
        return featureDao.queryForGeoJSONIndexedFeaturesWithBoundingBox(boundingBox);
    };
    /**
     * Create the Geometry Columns table if it does not already exist
     * @returns {Promise}
     */
    GeoPackage.prototype.createGeometryColumnsTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.geometryColumnsDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createGeometryColumns()];
            });
        });
    };
    /**
     * Get a Attribute DAO
     * @param  {string}   tableName table name
     * @returns {AttributeDao}
     */
    GeoPackage.prototype.getAttributeDaoWithTableName = function (tableName) {
        var contents = this.contentsDao.queryForId(tableName);
        return this.getAttributeDaoWithContents(contents);
    };
    /**
     * Get a Attribute DAO
     * @param  {Contents}   contents Contents
     * @returns {AttributeDao}
     */
    GeoPackage.prototype.getAttributeDaoWithContents = function (contents) {
        if (!contents) {
            throw new Error('Non null Contents is required to create an Attributes DAO');
        }
        var reader = new attributeTableReader_1.AttributeTableReader(contents.table_name);
        var table = reader.readTable(this.connection);
        table.setContents(contents);
        return new attributeDao_1.AttributeDao(this, table);
    };
    GeoPackage.prototype.createAttributeTable = function (tableName, columns, dataColumns) {
        return __awaiter(this, void 0, void 0, function () {
            var attributeTable, contents, dataColumnsDao_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attributeTable = new attributeTable_1.AttributeTable(tableName, columns);
                        this.tableCreator.createUserTable(attributeTable);
                        contents = new contents_1.Contents();
                        contents.table_name = tableName;
                        contents.data_type = contentsDao_1.ContentsDao.GPKG_CDT_ATTRIBUTES_NAME;
                        contents.identifier = tableName;
                        contents.last_change = new Date().toISOString();
                        this.contentsDao.create(contents);
                        if (!(dataColumns && dataColumns.length)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.createDataColumns()];
                    case 1:
                        _a.sent();
                        dataColumnsDao_2 = this.dataColumnsDao;
                        dataColumns.forEach(function (dataColumn) {
                            dataColumnsDao_2.create(dataColumn);
                        });
                        _a.label = 2;
                    case 2: return [2 /*return*/, true];
                }
            });
        });
    };
    /**
     * Create the given {@link module:features/user/featureTable~FeatureTable}
     * @param  {FeatureTable}   featureTable    feature table
     */
    GeoPackage.prototype.createFeatureTable = function (featureTable) {
        return this.tableCreator.createUserTable(featureTable);
    };
    GeoPackage.prototype.createFeatureTableWithGeometryColumns = function (geometryColumns, boundingBox, srsId, columns) {
        return this.createFeatureTableWithGeometryColumnsAndDataColumns(geometryColumns, boundingBox, srsId, columns, undefined);
    };
    GeoPackage.prototype.createFeatureTableWithGeometryColumnsAndDataColumns = function (geometryColumns, boundingBox, srsId, columns, dataColumns) {
        return __awaiter(this, void 0, void 0, function () {
            var featureTable, contents, dataColumnsDao_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createGeometryColumnsTable()];
                    case 1:
                        _a.sent();
                        featureTable = new featureTable_1.FeatureTable(geometryColumns.table_name, columns);
                        this.createFeatureTable(featureTable);
                        contents = new contents_1.Contents();
                        contents.table_name = geometryColumns.table_name;
                        contents.data_type = contentsDao_1.ContentsDao.GPKG_CDT_FEATURES_NAME;
                        contents.identifier = geometryColumns.table_name;
                        contents.last_change = new Date().toISOString();
                        contents.min_x = boundingBox.minLongitude;
                        contents.min_y = boundingBox.minLatitude;
                        contents.max_x = boundingBox.maxLongitude;
                        contents.max_y = boundingBox.maxLatitude;
                        contents.srs_id = srsId;
                        this.contentsDao.create(contents);
                        geometryColumns.srs_id = srsId;
                        this.geometryColumnsDao.create(geometryColumns);
                        if (!dataColumns) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.createDataColumns()];
                    case 2:
                        _a.sent();
                        dataColumnsDao_3 = this.dataColumnsDao;
                        dataColumns.forEach(function (dataColumn) {
                            dataColumnsDao_3.create(dataColumn);
                        });
                        _a.label = 3;
                    case 3: return [2 /*return*/, true];
                }
            });
        });
    };
    /**
     * Create the Tile Matrix Set table if it does not already exist
     * @returns {Promise} resolves when the table is created
     */
    GeoPackage.prototype.createTileMatrixSetTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.tileMatrixSetDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createTileMatrixSet()];
            });
        });
    };
    /**
     * Create the Tile Matrix table if it does not already exist
     * @returns {Promise} resolves when the table is created
     */
    GeoPackage.prototype.createTileMatrixTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.tileMatrixDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createTileMatrix()];
            });
        });
    };
    /**
     * Create the given tile table in this GeoPackage.
     *
     * @param  {module:tiles/user/tileTable~TileTable} tileTable
     * @return {object} the result of {@link module:db/geoPackageConnection~GeoPackageConnection#run}
     */
    GeoPackage.prototype.createTileTable = function (tileTable) {
        return this.tableCreator.createUserTable(tileTable);
    };
    /**
     * Create a new [tile table]{@link module:tiles/user/tileTable~TileTable} in this GeoPackage.
     *
     * @param {String} tableName tile table name
     * @param {BoundingBox} contentsBoundingBox bounding box of the contents table
     * @param {Number} contentsSrsId srs id of the contents table
     * @param {BoundingBox} tileMatrixSetBoundingBox bounding box of the matrix set
     * @param {Number} tileMatrixSetSrsId srs id of the matrix set
     * @returns {Promise<TileMatrixSet>} `Promise` of the created {@link module:tiles/matrixset~TileMatrixSet}
     */
    GeoPackage.prototype.createTileTableWithTableName = function (tableName, contentsBoundingBox, contentsSrsId, tileMatrixSetBoundingBox, tileMatrixSetSrsId) {
        return __awaiter(this, void 0, void 0, function () {
            var columns, tileTable, contents, tileMatrixSet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        columns = tileTable_1.TileTable.createRequiredColumns();
                        tileTable = new tileTable_1.TileTable(tableName, columns);
                        contents = new contents_1.Contents();
                        contents.table_name = tableName;
                        contents.data_type = contentsDao_1.ContentsDao.GPKG_CDT_TILES_NAME;
                        contents.identifier = tableName;
                        contents.last_change = new Date().toISOString();
                        contents.min_x = contentsBoundingBox.minLongitude;
                        contents.min_y = contentsBoundingBox.minLatitude;
                        contents.max_x = contentsBoundingBox.maxLongitude;
                        contents.max_y = contentsBoundingBox.maxLatitude;
                        contents.srs_id = contentsSrsId;
                        tileMatrixSet = new tileMatrixSet_1.TileMatrixSet();
                        tileMatrixSet.contents = contents;
                        tileMatrixSet.srs_id = tileMatrixSetSrsId;
                        tileMatrixSet.min_x = tileMatrixSetBoundingBox.minLongitude;
                        tileMatrixSet.min_y = tileMatrixSetBoundingBox.minLatitude;
                        tileMatrixSet.max_x = tileMatrixSetBoundingBox.maxLongitude;
                        tileMatrixSet.max_y = tileMatrixSetBoundingBox.maxLatitude;
                        return [4 /*yield*/, this.createTileMatrixSetTable()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.createTileMatrixTable()];
                    case 2:
                        _a.sent();
                        this.createTileTable(tileTable);
                        this.contentsDao.create(contents);
                        this.tileMatrixSetDao.create(tileMatrixSet);
                        return [2 /*return*/, tileMatrixSet];
                }
            });
        });
    };
    /**
     * Create the tables and rows necessary to store tiles in a {@link module:tiles/matrixset~TileMatrixSet}.
     * This will create a [tile matrix row]{@link module:tiles/matrix~TileMatrix}
     * for every integral zoom level in the range `[minZoom..maxZoom]`.
     *
     * @param {BoundingBox} epsg3857TileBoundingBox
     * @param {TileMatrixSet} tileMatrixSet
     * @param {number} minZoom
     * @param {number} maxZoom
     * @param {number} [tileSize=256] optional tile size in pixels
     * @returns {module:geoPackage~GeoPackage} `this` `GeoPackage`
     */
    GeoPackage.prototype.createStandardWebMercatorTileMatrix = function (epsg3857TileBoundingBox, tileMatrixSet, minZoom, maxZoom, tileSize) {
        if (tileSize === void 0) { tileSize = 256; }
        tileSize = tileSize || 256;
        var tileMatrixDao = this.tileMatrixDao;
        for (var zoom = minZoom; zoom <= maxZoom; zoom++) {
            var box = tileBoundingBoxUtils_1.TileBoundingBoxUtils.webMercatorTileBox(epsg3857TileBoundingBox, zoom);
            var matrixWidth = box.maxLongitude - box.minLongitude + 1;
            var matrixHeight = box.maxLatitude - box.minLatitude + 1;
            var pixelXSize = (epsg3857TileBoundingBox.maxLongitude - epsg3857TileBoundingBox.minLongitude) / matrixWidth / tileSize;
            var pixelYSize = (epsg3857TileBoundingBox.maxLatitude - epsg3857TileBoundingBox.minLatitude) / matrixHeight / tileSize;
            var tileMatrix = new tileMatrix_1.TileMatrix();
            tileMatrix.table_name = tileMatrixSet.table_name;
            tileMatrix.zoom_level = zoom;
            tileMatrix.matrix_width = matrixWidth;
            tileMatrix.matrix_height = matrixHeight;
            tileMatrix.tile_width = tileSize;
            tileMatrix.tile_height = tileSize;
            tileMatrix.pixel_x_size = pixelXSize;
            tileMatrix.pixel_y_size = pixelYSize;
            tileMatrixDao.create(tileMatrix);
        }
        return this;
    };
    /**
     * Adds a tile to the GeoPackage
     * @param  {object}   tileStream       Byte array or Buffer containing the tile bytes
     * @param  {String}   tableName  Table name to add the tile to
     * @param  {Number}   zoom       zoom level of this tile
     * @param  {Number}   tileRow    row of this tile
     * @param  {Number}   tileColumn column of this tile
     */
    GeoPackage.prototype.addTile = function (tileStream, tableName, zoom, tileRow, tileColumn) {
        var tileDao = this.getTileDao(tableName);
        var newRow = tileDao.newRow();
        newRow.zoomLevel = zoom;
        newRow.tileColumn = tileColumn;
        newRow.tileRow = tileRow;
        newRow.tileData = tileStream;
        return tileDao.create(newRow);
    };
    /**
     * Create the Data Columns table if it does not already exist
     */
    GeoPackage.prototype.createDataColumns = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.dataColumnsDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createDataColumns()];
            });
        });
    };
    /**
     * Create the Data Column Constraints table if it does not already exist
     */
    GeoPackage.prototype.createDataColumnConstraintsTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.dataColumnConstraintsDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createDataColumnConstraints()];
            });
        });
    };
    GeoPackage.prototype.createMetadataTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.metadataDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createMetadata()];
            });
        });
    };
    GeoPackage.prototype.createMetadataReferenceTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.metadataReferenceDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createMetadataReference()];
            });
        });
    };
    GeoPackage.prototype.createExtensionTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.extensionDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createExtensions()];
            });
        });
    };
    GeoPackage.prototype.createTableIndexTable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.tableIndexDao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createTableIndex()];
            });
        });
    };
    GeoPackage.prototype.createGeometryIndexTable = function (featureDao) {
        return __awaiter(this, void 0, void 0, function () {
            var dao;
            return __generator(this, function (_a) {
                dao = this.getGeometryIndexDao(featureDao);
                if (dao.isTableExists()) {
                    return [2 /*return*/, true];
                }
                return [2 /*return*/, this.tableCreator.createGeometryIndex()];
            });
        });
    };
    GeoPackage.prototype.createStyleMappingTable = function (tableName, columns, dataColumns) {
        return __awaiter(this, void 0, void 0, function () {
            var attributeTable, contents, dataColumnsDao_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attributeTable = new styleMappingTable_1.StyleMappingTable(tableName, columns);
                        this.tableCreator.createUserTable(attributeTable);
                        contents = new contents_1.Contents();
                        contents.table_name = tableName;
                        contents.data_type = contentsDao_1.ContentsDao.GPKG_CDT_ATTRIBUTES_NAME;
                        contents.identifier = tableName;
                        contents.last_change = new Date().toISOString();
                        this.contentsDao.create(contents);
                        if (!dataColumns) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.createDataColumns()];
                    case 1:
                        _a.sent();
                        dataColumnsDao_4 = this.dataColumnsDao;
                        dataColumns.forEach(function (dataColumn) {
                            dataColumnsDao_4.create(dataColumn);
                        });
                        _a.label = 2;
                    case 2: return [2 /*return*/, true];
                }
            });
        });
    };
    /**
     * Get the application id of the GeoPackage
     * @returns {string} application id
     */
    GeoPackage.prototype.getApplicationId = function () {
        return this.database.getApplicationId();
    };
    GeoPackage.prototype.getInfoForTable = function (tableDao) {
        var info = {
            tableName: tableDao.table_name,
            tableType: tableDao.table.getTableType(),
            count: tableDao.getCount(),
            geometryColumns: undefined,
            minZoom: undefined,
            maxZoom: undefined,
            minWebMapZoom: undefined,
            maxWebMapZoom: undefined,
            zoomLevels: undefined,
            tileMatrixSet: undefined,
            contents: undefined,
            srs: undefined,
            columns: undefined,
            columnMap: undefined,
        };
        if (tableDao instanceof featureDao_1.FeatureDao) {
            info.geometryColumns = {};
            info.geometryColumns.tableName = tableDao.geometryColumns.table_name;
            info.geometryColumns.geometryColumn = tableDao.geometryColumns.column_name;
            info.geometryColumns.geometryTypeName = tableDao.geometryColumns.geometry_type_name;
            info.geometryColumns.z = tableDao.geometryColumns.z;
            info.geometryColumns.m = tableDao.geometryColumns.m;
        }
        if (tableDao instanceof tileDao_1.TileDao) {
            info.minZoom = tableDao.minZoom;
            info.maxZoom = tableDao.maxZoom;
            info.minWebMapZoom = tableDao.minWebMapZoom;
            info.maxWebMapZoom = tableDao.maxWebMapZoom;
            info.zoomLevels = tableDao.tileMatrices.length;
        }
        var dao;
        var contentsRetriever;
        if (tableDao instanceof featureDao_1.FeatureDao) {
            dao = this.geometryColumnsDao;
            contentsRetriever = tableDao.geometryColumns;
        }
        else if (tableDao instanceof tileDao_1.TileDao) {
            dao = this.tileMatrixSetDao;
            contentsRetriever = tableDao.tileMatrixSet;
            info.tileMatrixSet = {};
            info.tileMatrixSet.srsId = tableDao.tileMatrixSet.srs_id;
            info.tileMatrixSet.minX = tableDao.tileMatrixSet.min_x;
            info.tileMatrixSet.maxX = tableDao.tileMatrixSet.max_x;
            info.tileMatrixSet.minY = tableDao.tileMatrixSet.min_y;
            info.tileMatrixSet.maxY = tableDao.tileMatrixSet.max_y;
        }
        var contents = dao.getContents(contentsRetriever);
        info.contents = {};
        info.contents.tableName = contents.table_name;
        info.contents.dataType = contents.data_type;
        info.contents.identifier = contents.identifier;
        info.contents.description = contents.description;
        info.contents.lastChange = contents.last_change;
        info.contents.minX = contents.min_x;
        info.contents.maxX = contents.max_x;
        info.contents.minY = contents.min_y;
        info.contents.maxY = contents.max_y;
        var contentsSrs = this.contentsDao.getSrs(contents);
        info.contents.srs = {
            name: contentsSrs.srs_name,
            id: contentsSrs.srs_id,
            organization: contentsSrs.organization,
            organization_coordsys_id: contentsSrs.organization_coordsys_id,
            definition: contentsSrs.definition,
            description: contentsSrs.description,
        };
        var srs = tableDao.getSrs();
        info.srs = {
            name: srs.srs_name,
            id: srs.srs_id,
            organization: srs.organization,
            organization_coordsys_id: srs.organization_coordsys_id,
            definition: srs.definition,
            description: srs.description,
        };
        info.columns = [];
        info.columnMap = {};
        var dcd = this.dataColumnsDao;
        tableDao.table.columns.forEach(function (column) {
            var dataColumn = dcd.getDataColumns(tableDao.table.table_name, column.name);
            info.columns.push({
                index: column.index,
                name: column.name,
                max: column.max,
                min: column.min,
                notNull: column.notNull,
                primaryKey: column.primaryKey,
                dataType: column.dataType ? dataTypes_1.DataTypes.nameFromType(column.dataType) : '',
                displayName: dataColumn && dataColumn.name ? dataColumn.name : column.name,
                dataColumn: dataColumn,
            });
            info.columnMap[column.name] = info.columns[info.columns.length - 1];
        }.bind(this));
        return info;
    };
    GeoPackage.loadProjections = function (items) {
        if (!items)
            throw new Error('Invalid array of projections');
        for (var i = 0; i < items.length; i++) {
            if (!defs[items[i]])
                throw new Error('Projection not found');
            this.addProjection(items[i], defs[items[i]]);
        }
    };
    GeoPackage.addProjection = function (name, definition) {
        if (!name || !definition)
            throw new Error('Invalid projection name/definition');
        proj4_1.default.defs('' + name, '' + definition);
    };
    GeoPackage.hasProjection = function (name) {
        return proj4_1.default.defs('' + name);
    };
    return GeoPackage;
}());
exports.GeoPackage = GeoPackage;
//# sourceMappingURL=geoPackage.js.map