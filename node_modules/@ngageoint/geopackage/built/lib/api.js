"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var geoPackage_1 = require("./geoPackage");
var geoPackageConnection_1 = require("./db/geoPackageConnection");
var dataColumnsDao_1 = require("./dataColumns/dataColumnsDao");
var mediaTable_1 = require("./extension/relatedTables/mediaTable");
var simpleAttributesTable_1 = require("./extension/relatedTables/simpleAttributesTable");
var relationType_1 = require("./extension/relatedTables/relationType");
var userColumn_1 = require("./user/userColumn");
var featureColumn_1 = require("./features/user/featureColumn");
var dataColumns_1 = require("./dataColumns/dataColumns");
var dataTypes_1 = require("./db/dataTypes");
var geometryColumns_1 = require("./features/columns/geometryColumns");
var geometryData_1 = require("./geom/geometryData");
var retriever_1 = require("./tiles/retriever");
var tileBoundingBoxUtils_1 = require("./tiles/tileBoundingBoxUtils");
var boundingBox_1 = require("./boundingBox");
var geoPackageValidate_1 = require("./validate/geoPackageValidate");
var features_1 = require("./tiles/features");
var wkx_1 = __importDefault(require("wkx"));
var reproject_1 = __importDefault(require("reproject"));
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var point_to_line_distance_1 = __importDefault(require("@turf/point-to-line-distance"));
var polygon_to_line_1 = __importDefault(require("@turf/polygon-to-line"));
var boolean_point_in_polygon_1 = __importDefault(require("@turf/boolean-point-in-polygon"));
var distance_1 = __importDefault(require("@turf/distance"));
var helpers = __importStar(require("@turf/helpers"));
/**
 * This module is the entry point to the GeoPackage API, providing static
 * methods for opening and building GeoPackage files.
 */
var GeoPackageAPI = /** @class */ (function () {
    function GeoPackageAPI() {
    }
    /**
     * In Node, open a GeoPackage file at the given path, or in a browser, load an
     * in-memory GeoPackage from the given byte array.
     * @param  {string|Uint8Array|Buffer} gppathOrByteArray path to the GeoPackage file or `Uint8Array` of GeoPackage bytes
     * @return {Promise<GeoPackage>} promise that resolves with the open {@link module:geoPackage~GeoPackage} object or rejects with an `Error`
     */
    GeoPackageAPI.open = function (gppathOrByteArray) {
        return __awaiter(this, void 0, void 0, function () {
            var valid, connection, geoPackage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        valid = typeof gppathOrByteArray !== 'string' ||
                            (typeof gppathOrByteArray === 'string' &&
                                (gppathOrByteArray.indexOf('http') === 0 ||
                                    !geoPackageValidate_1.GeoPackageValidate.validateGeoPackageExtension(gppathOrByteArray)));
                        if (!valid) {
                            throw new Error('Invalid GeoPackage - Invalid GeoPackage Extension');
                        }
                        return [4 /*yield*/, geoPackageConnection_1.GeoPackageConnection.connect(gppathOrByteArray)];
                    case 1:
                        connection = _a.sent();
                        if (gppathOrByteArray && typeof gppathOrByteArray === 'string') {
                            geoPackage = new geoPackage_1.GeoPackage(path_1.default.basename(gppathOrByteArray), gppathOrByteArray, connection);
                        }
                        else {
                            geoPackage = new geoPackage_1.GeoPackage('geopackage', undefined, connection);
                        }
                        if (geoPackageValidate_1.GeoPackageValidate.hasMinimumTables(geoPackage)) {
                            return [2 /*return*/, geoPackage];
                        }
                        else {
                            throw new Error('Invalid GeoPackage - GeoPackage does not have the minimum required tables');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * In Node, create a GeoPackage file at the given file path, or in a browser,
     * create an in-memory GeoPackage.
     * @param  {string} gppath path of the created GeoPackage file; ignored in the browser
     * @return {Promise<typeof GeoPackage>} promise that resolves with the open {@link module:geoPackage~GeoPackage} object or rejects with an  `Error`
     */
    GeoPackageAPI.create = function (gppath) {
        return __awaiter(this, void 0, void 0, function () {
            var valid, connection, geopackage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        valid = typeof gppath !== 'string' ||
                            (typeof gppath === 'string' && !geoPackageValidate_1.GeoPackageValidate.validateGeoPackageExtension(gppath));
                        if (!valid) {
                            throw new Error('Invalid GeoPackage');
                        }
                        if (typeof process !== 'undefined' && process.version && gppath) {
                            try {
                                fs_1.default.mkdirSync(path_1.default.dirname(gppath));
                            }
                            catch (e) {
                                // it's fine if we can't create the directory
                            }
                        }
                        return [4 /*yield*/, geoPackageConnection_1.GeoPackageConnection.connect(gppath)];
                    case 1:
                        connection = _a.sent();
                        connection.setApplicationId();
                        if (gppath) {
                            geopackage = new geoPackage_1.GeoPackage(path_1.default.basename(gppath), gppath, connection);
                        }
                        else {
                            geopackage = new geoPackage_1.GeoPackage('geopackage', undefined, connection);
                        }
                        return [4 /*yield*/, geopackage.createRequiredTables()];
                    case 2:
                        _a.sent();
                        geopackage.createSupportedExtensions();
                        return [2 /*return*/, geopackage];
                }
            });
        });
    };
    /**
     * Create the [tables and rows](https://www.geopackage.org/spec121/index.html#tiles)
     * necessary to store tiles according to the ubiquitous [XYZ web/slippy-map tiles](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames) scheme.
     * The extent for the [contents table]{@link module:core/contents~Contents} row,
     * `contentsBoundingBox`, is [informational only](https://www.geopackage.org/spec121/index.html#gpkg_contents_cols),
     * and need not match the [tile matrix set]{@link module:tiles/matrixset~TileMatrixSet}
     * extent, `tileMatrixSetBoundingBox`, which should be the precise bounding box
     * used to calculate the tile row and column coordinates of all tiles in the
     * tile set.  The two SRS ID parameters, `contentsSrsId` and `tileMatrixSetSrsId`,
     * must match, however.  See {@link module:tiles/matrixset~TileMatrixSet} for
     * more information about how GeoPackage consumers use the bouding boxes for a
     * tile set.
     *
     * @param {module:geoPackage~GeoPackage} geopackage the GeoPackage that will store the tiles
     * @param {string} tableName the name of the table that will store the tiles
     * @param {BoundingBox} contentsBoundingBox the bounds stored in the [`gpkg_contents`]{@link module:core/contents~Contents} table row for the tile matrix set
     * @param {SRSRef} contentsSrsId the ID of a [spatial reference system]{@link module:core/srs~SpatialReferenceSystem}; must match `tileMatrixSetSrsId`
     * @param {BoundingBox} tileMatrixSetBoundingBox the bounds stored in the [`gpkg_tile_matrix_set`]{@link module:tiles/matrixset~TileMatrixSet} table row
     * @param {SRSRef} tileMatrixSetSrsId the ID of a [spatial reference system]{@link module:core/srs~SpatialReferenceSystem}
     *   for the [tile matrix set](https://www.geopackage.org/spec121/index.html#_tile_matrix_set) table; must match `contentsSrsId`
     * @param {number} minZoom the zoom level of the lowest resolution [tile matrix]{@link module:tiles/matrix~TileMatrix} in the tile matrix set
     * @param {number} maxZoom the zoom level of the highest resolution [tile matrix]{@link module:tiles/matrix~TileMatrix} in the tile matrix set
     * @param tileSize the width and height in pixels of the tile images; defaults to 256
     * @returns {Promise} a `Promise` that resolves with the created {@link module:tiles/matrixset~TileMatrixSet} object, or rejects with an `Error`
     *
     * @todo make `tileMatrixSetSrsId` optional because it always has to be the same anyway
     */
    GeoPackageAPI.createStandardWebMercatorTileTable = function (geopackage, tableName, contentsBoundingBox, contentsSrsId, tileMatrixSetBoundingBox, tileMatrixSetSrsId, minZoom, maxZoom, tileSize) {
        if (tileSize === void 0) { tileSize = 256; }
        return __awaiter(this, void 0, void 0, function () {
            var tileMatrixSet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, geopackage.createTileTableWithTableName(tableName, contentsBoundingBox, contentsSrsId, tileMatrixSetBoundingBox, tileMatrixSetSrsId)];
                    case 1:
                        tileMatrixSet = _a.sent();
                        geopackage.createStandardWebMercatorTileMatrix(tileMatrixSetBoundingBox, tileMatrixSet, minZoom, maxZoom, tileSize);
                        return [2 /*return*/, tileMatrixSet];
                }
            });
        });
    };
    GeoPackageAPI.createFeatureTable = function (geopackage, tableName, featureColumns, geometryColumn, dataColumns, boundingBox, boundingBoxSrsId) {
        if (boundingBox === void 0) { boundingBox = new boundingBox_1.BoundingBox(-180, 180, -90, 90); }
        if (boundingBoxSrsId === void 0) { boundingBoxSrsId = 4326; }
        return __awaiter(this, void 0, void 0, function () {
            var geometryColumns, columns, columnNumber, i, property;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        geometryColumns = geometryColumn || new geometryColumns_1.GeometryColumns();
                        geometryColumns.table_name = tableName;
                        geometryColumns.column_name = 'geometry';
                        geometryColumns.geometry_type_name = 'GEOMETRY';
                        geometryColumns.z = 0;
                        geometryColumns.m = 0;
                        columns = [];
                        if (featureColumns && featureColumns.length > 0 && featureColumns[0] instanceof userColumn_1.UserColumn) {
                            columns = featureColumns;
                        }
                        else {
                            columnNumber = 0;
                            columns.push(featureColumn_1.FeatureColumn.createPrimaryKeyColumnWithIndexAndName(columnNumber++, 'id'));
                            columns.push(featureColumn_1.FeatureColumn.createGeometryColumn(columnNumber++, geometryColumns.column_name, geometryColumns.geometry_type_name, false, null));
                            for (i = 0; featureColumns && i < featureColumns.length; i++) {
                                property = featureColumns[i];
                                columns.push(featureColumn_1.FeatureColumn.createColumn(columnNumber++, property.name, dataTypes_1.DataTypes.fromName(property.dataType)));
                            }
                        }
                        return [4 /*yield*/, geopackage.createFeatureTableWithGeometryColumnsAndDataColumns(geometryColumns, boundingBox, boundingBoxSrsId, columns, dataColumns)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, geopackage.getFeatureDao(tableName)];
                }
            });
        });
    };
    /**
     * Create a feature table with the properties specified.
     * @param {module:geoPackage~GeoPackage} geopackage the geopackage object
     * @param tableName name of the table to create
     * @param {Object[]} properties properties to create columns from
     * @param {string} properties.name name of the column
     * @param {string} properties.dataType name of the data type
     * @param {DataColumns} [properties.dataColumn] data column for the property
     * @return {Promise}
     */
    GeoPackageAPI.createAttributeTable = function (geopackage, tableName, properties) {
        return __awaiter(this, void 0, void 0, function () {
            var columns, columnNumber, dataColumns, i, property, dc;
            return __generator(this, function (_a) {
                columns = [];
                columnNumber = 0;
                columns.push(userColumn_1.UserColumn.createPrimaryKeyColumnWithIndexAndName(columnNumber++, 'id'));
                dataColumns = [];
                for (i = 0; i < properties.length; i++) {
                    property = properties[i];
                    columns.push(userColumn_1.UserColumn.createColumn(columnNumber++, property.name, dataTypes_1.DataTypes.fromName(property.dataType)));
                    if (property.dataColumn) {
                        dc = new dataColumns_1.DataColumns();
                        dc.table_name = property.dataColumn.table_name;
                        dc.column_name = property.dataColumn.column_name;
                        dc.name = property.dataColumn.name;
                        dc.title = property.dataColumn.title;
                        dc.description = property.dataColumn.description;
                        dc.mime_type = property.dataColumn.mime_type;
                        dc.constraint_name = property.dataColumn.constraint_name;
                        dataColumns.push(dc);
                    }
                }
                return [2 /*return*/, geopackage.createAttributeTable(tableName, columns, dataColumns)];
            });
        });
    };
    GeoPackageAPI.addAttributeRow = function (geopackage, tableName, row) {
        var attributeDao = geopackage.getAttributeDaoWithTableName(tableName);
        var attributeRow = attributeDao.getRow(row);
        return attributeDao.create(attributeRow);
    };
    /**
     * Create a simple attributes table with the properties specified.
     * @param {module:geoPackage~GeoPackage} geopackage the geopackage object
     * @param {Object[]} properties properties to create columns from
     * @param {string} properties.name name of the column
     * @param {string} properties.dataType name of the data type
     * @return {Promise}
     */
    GeoPackageAPI.createSimpleAttributesTable = function (geopackage, tableName, properties) {
        var relatedTables = geopackage.relatedTablesExtension;
        var columns = [];
        var columnNumber = simpleAttributesTable_1.SimpleAttributesTable.numRequiredColumns();
        if (properties) {
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i];
                columns.push(userColumn_1.UserColumn.createColumn(columnNumber++, property.name, dataTypes_1.DataTypes.fromName(property.dataType), true));
            }
        }
        var simpleAttributesTable = simpleAttributesTable_1.SimpleAttributesTable.create(tableName, columns);
        relatedTables.createRelatedTable(simpleAttributesTable);
        return relatedTables.getSimpleAttributesDao(simpleAttributesTable);
    };
    /**
     * Create a media table with the properties specified.  These properties are added to the required columns
     * @param {module:geoPackage~GeoPackage} geopackage the geopackage object
     * @param {Object[]} properties properties to create columns from
     * @param {string} properties.name name of the column
     * @param {string} properties.dataType name of the data type
     * @return {Promise}
     */
    GeoPackageAPI.createMediaTable = function (geopackage, tableName, properties) {
        var relatedTables = geopackage.relatedTablesExtension;
        var columns = [];
        var columnNumber = mediaTable_1.MediaTable.numRequiredColumns();
        if (properties) {
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i];
                columns.push(userColumn_1.UserColumn.createColumn(columnNumber++, property.name, dataTypes_1.DataTypes.fromName(property.dataType), property.notNull, property.defaultValue, property.max));
            }
        }
        var mediaTable = mediaTable_1.MediaTable.create(tableName, columns);
        relatedTables.createRelatedTable(mediaTable);
        return relatedTables.getMediaDao(mediaTable);
    };
    GeoPackageAPI.addMedia = function (geopackage, tableName, dataBuffer, contentType, additionalProperties) {
        var relatedTables = geopackage.relatedTablesExtension;
        var mediaDao = relatedTables.getMediaDao(tableName);
        var row = mediaDao.newRow();
        row.setContentType(contentType);
        row.setData(dataBuffer);
        for (var key in additionalProperties) {
            row.setValueWithColumnName(key, additionalProperties[key]);
        }
        return mediaDao.create(row);
    };
    GeoPackageAPI.linkMedia = function (geopackage, baseTableName, baseId, mediaTableName, mediaId) {
        return __awaiter(this, void 0, void 0, function () {
            var relatedTables;
            return __generator(this, function (_a) {
                relatedTables = geopackage.relatedTablesExtension;
                return [2 /*return*/, relatedTables.linkRelatedIds(baseTableName, baseId, mediaTableName, mediaId, relationType_1.RelationType.MEDIA)];
            });
        });
    };
    GeoPackageAPI.getLinkedMedia = function (geopackage, baseTableName, baseId) {
        var relationships = GeoPackageAPI.getRelatedRows(geopackage, baseTableName, baseId);
        var mediaRelationships = [];
        for (var i = 0; i < relationships.length; i++) {
            var relationship = relationships[i];
            if (relationship.relation_name === relationType_1.RelationType.MEDIA.name) {
                for (var r = 0; r < relationship.mappingRows.length; r++) {
                    var row = relationship.mappingRows[r].row;
                    mediaRelationships.push(row);
                }
            }
        }
        return mediaRelationships;
    };
    GeoPackageAPI.getRelatedRows = function (geopackage, baseTableName, baseId) {
        return geopackage.relatedTablesExtension.getRelatedRows(baseTableName, baseId);
    };
    /**
     * Adds a GeoJSON feature to the GeoPackage
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {object}   feature    GeoJSON feature to add
     * @param  {string}   tableName  name of the table that will store the feature
     * @param {boolean} index updates the FeatureTableIndex extension if it exists
     */
    GeoPackageAPI.addGeoJSONFeatureToGeoPackage = function (geopackage, feature, tableName, index) {
        if (index === void 0) { index = false; }
        var featureDao = geopackage.getFeatureDao(tableName);
        var srs = featureDao.getSrs();
        var featureRow = featureDao.newRow();
        var geometryData = new geometryData_1.GeometryData();
        geometryData.setSrsId(srs.srs_id);
        if (!(srs.organization === 'EPSG' && srs.organization_coordsys_id === 4326)) {
            feature = reproject_1.default.reproject(feature, 'EPSG:4326', featureDao.projection);
        }
        var featureGeometry = typeof feature.geometry === 'string' ? JSON.parse(feature.geometry) : feature.geometry;
        var geometry = wkx_1.default.Geometry.parseGeoJSON(featureGeometry);
        geometryData.setGeometry(geometry);
        featureRow.setGeometry(geometryData);
        for (var propertyKey in feature.properties) {
            if (Object.prototype.hasOwnProperty.call(feature.properties, propertyKey)) {
                featureRow.setValueWithColumnName(propertyKey, feature.properties[propertyKey]);
            }
        }
        var id = featureDao.create(featureRow);
        if (index) {
            var fti = featureDao.featureTableIndex;
            var tableIndex = fti.getTableIndex();
            if (!tableIndex)
                return id;
            fti.indexRow(tableIndex, id, geometryData);
            fti.updateLastIndexed(tableIndex);
        }
        return id;
    };
    /**
     * Queries for GeoJSON features in a feature tables
     * @param  {string}   geoPackagePath  path to the GeoPackage file
     * @param  {string}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     */
    GeoPackageAPI.queryForGeoJSONFeaturesInTableFromPath = function (geoPackagePath, tableName, boundingBox) {
        return __awaiter(this, void 0, void 0, function () {
            var geoPackage, features;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, GeoPackageAPI.open(geoPackagePath)];
                    case 1:
                        geoPackage = _a.sent();
                        features = geoPackage.queryForGeoJSONFeaturesInTable(tableName, boundingBox);
                        geoPackage.close();
                        return [2 /*return*/, features];
                }
            });
        });
    };
    /**
     * Queries for GeoJSON features in a feature tables
     * @param  {module:geoPackage~GeoPackage}   geoPackage  open GeoPackage object
     * @param  {string}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     */
    GeoPackageAPI.queryForGeoJSONFeaturesInTable = function (geoPackage, tableName, boundingBox) {
        return geoPackage.queryForGeoJSONFeaturesInTable(tableName, boundingBox);
    };
    /**
     * Iterates GeoJSON features in a feature table that matches the bounding box
     * @param  {module:geoPackage~GeoPackage}   geoPackage  open GeoPackage object
     * @param  {string}   tableName   Table name to query
     * @param  {BoundingBox}   boundingBox BoundingBox to query
     */
    GeoPackageAPI.iterateGeoJSONFeatures = function (geoPackage, tableName, boundingBox) {
        return __awaiter(this, void 0, void 0, function () {
            var gp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(geoPackage instanceof geoPackage_1.GeoPackage)) return [3 /*break*/, 1];
                        return [2 /*return*/, geoPackage.iterateGeoJSONFeaturesInTableWithinBoundingBox(tableName, boundingBox)];
                    case 1: return [4 /*yield*/, GeoPackageAPI.open(geoPackage)];
                    case 2:
                        gp = _a.sent();
                        return [2 /*return*/, gp.iterateGeoJSONFeaturesInTableWithinBoundingBox(tableName, boundingBox)];
                }
            });
        });
    };
    GeoPackageAPI.createDataColumnMap = function (featureDao) {
        var columnMap = {};
        var dcd = new dataColumnsDao_1.DataColumnsDao(featureDao.geoPackage);
        featureDao.table.columns.forEach(function (column) {
            var dataColumn = dcd.getDataColumns(featureDao.table.table_name, column.name);
            columnMap[column.name] = {
                index: column.index,
                name: column.name,
                max: column.max,
                min: column.min,
                notNull: column.notNull,
                primaryKey: column.primaryKey,
                dataType: column.dataType ? dataTypes_1.DataTypes.nameFromType(column.dataType) : '',
                displayName: dataColumn && dataColumn.name ? dataColumn.name : column.name,
                dataColumn: dataColumn,
            };
        }.bind(this));
        return columnMap;
    };
    /**
     * @typedef {Object} GeoJSONFeatureIterator
     * @property {SpatialReferenceSystem} srs SRS of the iterator
     * @property {FeatureDao} featureDao featureDao of the iterator objects
     * @property {IterableIterator<FeatureRow>} results iterator of results
     */
    /**
     * Iterate GeoJSON features from table
     * @param  {module:geoPackage~GeoPackage} geopackage      open GeoPackage object
     * @param  {string} table           Table name to Iterate
     * @return {GeoJSONFeatureIterator}
     */
    GeoPackageAPI.iterateGeoJSONFeaturesFromTable = function (geopackage, table) {
        var _a;
        var featureDao = geopackage.getFeatureDao(table);
        if (!featureDao) {
            throw new Error('No Table exists with the name ' + table);
        }
        var columnMap = GeoPackageAPI.createDataColumnMap(featureDao);
        var srs = featureDao.getSrs();
        var iterator = featureDao.queryForEach();
        return {
            srs: srs,
            featureDao: featureDao,
            results: (_a = {},
                _a[Symbol.iterator] = function () {
                    return this;
                },
                _a.next = function () {
                    var nextRow = iterator.next();
                    if (!nextRow.done) {
                        var featureRow = void 0;
                        var geometry = void 0;
                        while (!nextRow.done && !geometry) {
                            featureRow = featureDao.getRow(nextRow.value);
                            return {
                                value: GeoPackageAPI.parseFeatureRowIntoGeoJSON(featureRow, srs, columnMap),
                                done: false,
                            };
                        }
                    }
                    return {
                        value: undefined,
                        done: true,
                    };
                }.bind(this),
                _a),
        };
    };
    /**
     * Gets a GeoJSON feature from the table by id
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table to get the feature from
     * @param  {Number}   featureId  ID of the feature
     */
    GeoPackageAPI.getFeature = function (geopackage, table, featureId) {
        var featureDao = geopackage.getFeatureDao(table);
        var srs = featureDao.getSrs();
        var feature = featureDao.queryForId(featureId);
        if (!feature) {
            var features = featureDao.queryForAllEq('_feature_id', featureId);
            if (features.length) {
                feature = featureDao.getRow(features[0]);
            }
            else {
                features = featureDao.queryForAllEq('_properties_id', featureId);
                if (features.length) {
                    feature = featureDao.getRow(features[0]);
                }
            }
        }
        if (feature) {
            return GeoPackageAPI.parseFeatureRowIntoGeoJSON(feature, srs);
        }
    };
    // eslint-disable-next-line complexity
    GeoPackageAPI.parseFeatureRowIntoGeoJSON = function (featureRow, srs, columnMap) {
        var geoJson = {
            type: 'Feature',
            properties: {},
            id: undefined,
            geometry: undefined,
        };
        var geometry = featureRow.getGeometry();
        if (geometry && geometry.geometry) {
            var geoJsonGeom = geometry.geometry.toGeoJSON();
            if (srs.definition &&
                srs.definition !== 'undefined' &&
                srs.organization.toUpperCase() + ':' + srs.organization_coordsys_id !== 'EPSG:4326') {
                geoJsonGeom = reproject_1.default.reproject(geoJsonGeom, srs.projection, 'EPSG:4326');
            }
            geoJson.geometry = geoJsonGeom;
        }
        for (var key in featureRow.values) {
            if (Object.prototype.hasOwnProperty.call(featureRow.values, key) &&
                key !== featureRow.getGeometryColumn().name &&
                key !== 'id') {
                if (key.toLowerCase() === '_feature_id') {
                    geoJson.id = featureRow.values[key];
                }
                else if (key.toLowerCase() === '_properties_id') {
                    geoJson.properties[key.substring(12)] = featureRow.values[key];
                }
                else if (columnMap && columnMap[key]) {
                    geoJson.properties[columnMap[key].displayName] = featureRow.values[key];
                }
                else {
                    geoJson.properties[key] = featureRow.values[key];
                }
            }
            else if (featureRow.getGeometryColumn().name === key) {
                // geoJson.properties[key] = geometry && !geometry.geometryError ? 'Valid' : geometry.geometryError;
            }
        }
        geoJson.id = geoJson.id || featureRow.getId();
        return geoJson;
    };
    /**
     * Gets a tile from the specified table
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table to get the tile from
     * @param  {Number}   zoom       zoom level of the tile
     * @param  {Number}   tileRow    row of the tile
     * @param  {Number}   tileColumn column of the tile
     *
     * @todo jsdoc return value
     */
    GeoPackageAPI.getTileFromTable = function (geopackage, table, zoom, tileRow, tileColumn) {
        var tileDao = geopackage.getTileDao(table);
        return tileDao.queryForTile(tileColumn, tileRow, zoom);
    };
    /**
     * Gets the tiles in the EPSG:4326 bounding box
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the tile table
     * @param  {Number}   zoom       Zoom of the tiles to query for
     * @param  {Number}   west       EPSG:4326 western boundary
     * @param  {Number}   east       EPSG:4326 eastern boundary
     * @param  {Number}   south      EPSG:4326 southern boundary
     * @param  {Number}   north      EPSG:4326 northern boundary
     */
    GeoPackageAPI.getTilesInBoundingBox = function (geopackage, table, zoom, west, east, south, north) {
        var e_1, _a;
        var tiles = {
            columns: [],
            srs: undefined,
            tiles: [],
            west: undefined,
            east: undefined,
            south: undefined,
            north: undefined,
            zoom: undefined,
        };
        var tileDao = geopackage.getTileDao(table);
        if (zoom < tileDao.minZoom || zoom > tileDao.maxZoom) {
            return;
        }
        for (var i = 0; i < tileDao.table.columns.length; i++) {
            var column = tileDao.table.columns[i];
            tiles.columns.push({
                index: column.index,
                name: column.name,
                max: column.max,
                min: column.min,
                notNull: column.notNull,
                primaryKey: column.primaryKey,
            });
        }
        var srs = tileDao.getSrs();
        tiles.srs = srs;
        tiles.tiles = [];
        var tms = tileDao.tileMatrixSet;
        var tm = tileDao.getTileMatrixWithZoomLevel(zoom);
        if (!tm) {
            return tiles;
        }
        var mapBoundingBox = new boundingBox_1.BoundingBox(Math.max(-180, west), Math.min(east, 180), south, north);
        tiles.west = Math.max(-180, west).toFixed(2);
        tiles.east = Math.min(east, 180).toFixed(2);
        tiles.south = south.toFixed(2);
        tiles.north = north.toFixed(2);
        tiles.zoom = zoom;
        mapBoundingBox = mapBoundingBox.projectBoundingBox('EPSG:4326', tileDao.srs.organization.toUpperCase() + ':' + tileDao.srs.organization_coordsys_id);
        var grid = tileBoundingBoxUtils_1.TileBoundingBoxUtils.getTileGridWithTotalBoundingBox(tms.boundingBox, tm.matrix_width, tm.matrix_height, mapBoundingBox);
        var iterator = tileDao.queryByTileGrid(grid, zoom);
        try {
            for (var iterator_1 = __values(iterator), iterator_1_1 = iterator_1.next(); !iterator_1_1.done; iterator_1_1 = iterator_1.next()) {
                var row = iterator_1_1.value;
                var tile = {};
                tile.tableName = table;
                tile.id = row.getId();
                var tileBB = tileBoundingBoxUtils_1.TileBoundingBoxUtils.getTileBoundingBox(tms.boundingBox, tm, row.tileColumn, row.row);
                tile.minLongitude = tileBB.minLongitude;
                tile.maxLongitude = tileBB.maxLongitude;
                tile.minLatitude = tileBB.minLatitude;
                tile.maxLatitude = tileBB.maxLatitude;
                tile.projection = tileDao.srs.organization.toUpperCase() + ':' + tileDao.srs.organization_coordsys_id;
                tile.values = [];
                for (var i = 0; i < tiles.columns.length; i++) {
                    var value = row.values[tiles.columns[i].name];
                    if (tiles.columns[i].name === 'tile_data') {
                        tile.values.push('data');
                    }
                    else if (value === null || value === 'null') {
                        tile.values.push('');
                    }
                    else {
                        tile.values.push(value.toString());
                        tile[tiles.columns[i].name] = value;
                    }
                }
                tiles.tiles.push(tile);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) _a.call(iterator_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return tiles;
    };
    /**
     * Gets the tiles in the EPSG:4326 bounding box
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the tile table
     * @param  {Number}   webZoom       Zoom of the tiles to query for
     * @param  {Number}   west       EPSG:4326 western boundary
     * @param  {Number}   east       EPSG:4326 eastern boundary
     * @param  {Number}   south      EPSG:4326 southern boundary
     * @param  {Number}   north      EPSG:4326 northern boundary
     */
    GeoPackageAPI.getTilesInBoundingBoxWebZoom = function (geopackage, table, webZoom, west, east, south, north) {
        var e_2, _a;
        var tiles = {
            columns: [],
            srs: undefined,
            tiles: [],
            west: undefined,
            east: undefined,
            south: undefined,
            north: undefined,
            zoom: undefined,
        };
        var tileDao = geopackage.getTileDao(table);
        if (webZoom < tileDao.minWebMapZoom || webZoom > tileDao.minWebMapZoom) {
            return;
        }
        tiles.columns = [];
        for (var i = 0; i < tileDao.table.columns.length; i++) {
            var column = tileDao.table.columns[i];
            tiles.columns.push({
                index: column.index,
                name: column.name,
                max: column.max,
                min: column.min,
                notNull: column.notNull,
                primaryKey: column.primaryKey,
            });
        }
        var srs = tileDao.getSrs();
        tiles.srs = srs;
        tiles.tiles = [];
        var zoom = tileDao.webZoomToGeoPackageZoom(webZoom);
        var tms = tileDao.tileMatrixSet;
        var tm = tileDao.getTileMatrixWithZoomLevel(zoom);
        if (!tm) {
            return tiles;
        }
        var mapBoundingBox = new boundingBox_1.BoundingBox(Math.max(-180, west), Math.min(east, 180), south, north);
        tiles.west = Math.max(-180, west).toFixed(2);
        tiles.east = Math.min(east, 180).toFixed(2);
        tiles.south = south.toFixed(2);
        tiles.north = north.toFixed(2);
        tiles.zoom = zoom;
        mapBoundingBox = mapBoundingBox.projectBoundingBox('EPSG:4326', tileDao.srs.organization.toUpperCase() + ':' + tileDao.srs.organization_coordsys_id);
        var grid = tileBoundingBoxUtils_1.TileBoundingBoxUtils.getTileGridWithTotalBoundingBox(tms.boundingBox, tm.matrix_width, tm.matrix_height, mapBoundingBox);
        var iterator = tileDao.queryByTileGrid(grid, zoom);
        try {
            for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {
                var row = iterator_2_1.value;
                var tile = {
                    tableName: undefined,
                    id: undefined,
                    minLongitude: undefined,
                    maxLongitude: undefined,
                    minLatitude: undefined,
                    maxLatitude: undefined,
                    projection: undefined,
                    values: [],
                };
                tile.tableName = table;
                tile.id = row.getId();
                var tileBB = tileBoundingBoxUtils_1.TileBoundingBoxUtils.getTileBoundingBox(tms.boundingBox, tm, row.tileColumn, row.row);
                tile.minLongitude = tileBB.minLongitude;
                tile.maxLongitude = tileBB.maxLongitude;
                tile.minLatitude = tileBB.minLatitude;
                tile.maxLatitude = tileBB.maxLatitude;
                tile.projection = tileDao.srs.organization.toUpperCase() + ':' + tileDao.srs.organization_coordsys_id;
                tile.values = [];
                for (var i = 0; i < tiles.columns.length; i++) {
                    var value = row.values[tiles.columns[i].name];
                    if (tiles.columns[i].name === 'tile_data') {
                        tile.values.push('data');
                    }
                    else if (value === null || value === 'null') {
                        tile.values.push('');
                    }
                    else {
                        tile.values.push(value.toString());
                        tile[tiles.columns[i].name] = value;
                    }
                }
                tiles.tiles.push(tile);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return tiles;
    };
    GeoPackageAPI.getFeatureTileFromXYZ = function (geopackage, table, x, y, z, width, height) {
        return __awaiter(this, void 0, void 0, function () {
            var featureDao, ft;
            return __generator(this, function (_a) {
                x = Number(x);
                y = Number(y);
                z = Number(z);
                width = Number(width);
                height = Number(height);
                featureDao = geopackage.getFeatureDao(table);
                if (!featureDao)
                    return [2 /*return*/];
                ft = new features_1.FeatureTiles(featureDao, width, height);
                return [2 /*return*/, ft.drawTile(x, y, z)];
            });
        });
    };
    GeoPackageAPI.getClosestFeatureInXYZTile = function (geopackage, table, x, y, z, latitude, longitude) {
        var e_3, _a;
        x = Number(x);
        y = Number(y);
        z = Number(z);
        var featureDao = geopackage.getFeatureDao(table);
        if (!featureDao)
            return;
        var ft = new features_1.FeatureTiles(featureDao, 256, 256);
        var tileCount = ft.getFeatureCountXYZ(x, y, z);
        var boundingBox = tileBoundingBoxUtils_1.TileBoundingBoxUtils.getWebMercatorBoundingBoxFromXYZ(x, y, z);
        boundingBox = boundingBox.projectBoundingBox('EPSG:3857', 'EPSG:4326');
        if (tileCount > 10000) {
            // too many, send back the entire tile
            // add the goepackage name and table
            var gj = boundingBox.toGeoJSON();
            gj.feature_count = tileCount;
            gj.coverage = true;
            gj.gp_table = table;
            gj.gp_name = geopackage.name;
            return gj;
        }
        var ne = [boundingBox.maxLongitude, boundingBox.maxLatitude];
        var sw = [boundingBox.minLongitude, boundingBox.minLatitude];
        var width = ne[0] - sw[0];
        var widthPerPixel = width / 256;
        var tolerance = 10 * widthPerPixel;
        boundingBox.maxLongitude = longitude + tolerance;
        boundingBox.minLongitude = longitude - tolerance;
        boundingBox.maxLatitude = latitude + tolerance;
        boundingBox.minLatitude = latitude - tolerance;
        var iterator = featureDao.queryForGeoJSONIndexedFeaturesWithBoundingBox(boundingBox);
        var features = [];
        var closestDistance = 100000000000;
        var closest;
        var centerPoint = helpers.point([longitude, latitude]);
        try {
            for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {
                var feature = iterator_3_1.value;
                feature.type = 'Feature';
                var distance = GeoPackageAPI.determineDistance(centerPoint.geometry, feature);
                if (distance < closestDistance) {
                    closest = feature;
                    closestDistance = distance;
                }
                else if (distance === closestDistance && closest.type !== 'Point') {
                    closest = feature;
                    closestDistance = distance;
                }
                features.push(feature);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (closest) {
            closest.gp_table = table;
            closest.gp_name = geopackage.name;
            closest.distance = closestDistance;
        }
        return closest;
    };
    GeoPackageAPI.determineDistance = function (point, feature) {
        if (feature.type === 'FeatureCollection') {
            feature.features.forEach(function (feature) {
                GeoPackageAPI.determineDistance(point, feature);
            });
        }
        else {
            var geometry = feature.geometry;
            if (geometry.type === 'Point') {
                return distance_1.default(point, geometry);
            }
            if (geometry.type === 'LineString') {
                return this.determineDistanceFromLine(point, geometry);
            }
            if (geometry.type === 'MultiLineString') {
                var distance_2 = Number.MAX_SAFE_INTEGER;
                geometry.coordinates.forEach(function (lineStringCoordinate) {
                    var lineString = helpers.lineString(lineStringCoordinate);
                    distance_2 = Math.min(distance_2, GeoPackageAPI.determineDistance(point, lineString));
                });
                return distance_2;
            }
            if (geometry.type === 'Polygon') {
                return GeoPackageAPI.determineDistanceFromPolygon(point, geometry);
            }
            if (geometry.type === 'MultiPolygon') {
                return GeoPackageAPI.determineDistanceFromPolygon(point, geometry);
            }
            return Number.MAX_SAFE_INTEGER;
        }
    };
    GeoPackageAPI.determineDistanceFromLine = function (point, lineString) {
        return point_to_line_distance_1.default(point, lineString);
    };
    GeoPackageAPI.determineDistanceFromPolygon = function (point, polygon) {
        if (boolean_point_in_polygon_1.default(point, polygon)) {
            return 0;
        }
        return GeoPackageAPI.determineDistance(point, polygon_to_line_1.default(polygon));
    };
    /**
     * Gets the features in the EPSG:3857 tile
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the feature table
     * @param  {Number}   x       x tile number
     * @param  {Number}   y       y tile number
     * @param  {Number}   z      z tile number
     * @param  {Boolean}   [skipVerification]      skip the extra verification to determine if the feature really is within the tile
     */
    GeoPackageAPI.getGeoJSONFeaturesInTile = function (geopackage, table, x, y, z, skipVerification) {
        if (skipVerification === void 0) { skipVerification = false; }
        return __awaiter(this, void 0, void 0, function () {
            var webMercatorBoundingBox, bb, featureDao, features, iterator, iterator_4, iterator_4_1, feature;
            var e_4, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        webMercatorBoundingBox = tileBoundingBoxUtils_1.TileBoundingBoxUtils.getWebMercatorBoundingBoxFromXYZ(x, y, z);
                        bb = webMercatorBoundingBox.projectBoundingBox('EPSG:3857', 'EPSG:4326');
                        return [4 /*yield*/, geopackage.indexFeatureTable(table)];
                    case 1:
                        _b.sent();
                        featureDao = geopackage.getFeatureDao(table);
                        if (!featureDao)
                            return [2 /*return*/];
                        features = [];
                        iterator = featureDao.queryForGeoJSONIndexedFeaturesWithBoundingBox(bb, skipVerification);
                        try {
                            for (iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {
                                feature = iterator_4_1.value;
                                features.push(feature);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        return [2 /*return*/, features];
                }
            });
        });
    };
    /**
     * Gets the features in the EPSG:4326 bounding box
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the feature table
     * @param  {Number}   west       EPSG:4326 western boundary
     * @param  {Number}   east       EPSG:4326 eastern boundary
     * @param  {Number}   south      EPSG:4326 southern boundary
     * @param  {Number}   north      EPSG:4326 northern boundary
     */
    GeoPackageAPI.getFeaturesInBoundingBox = function (geopackage, table, west, east, south, north) {
        return __awaiter(this, void 0, void 0, function () {
            var featureDao, bb, iterator;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, geopackage.indexFeatureTable(table)];
                    case 1:
                        _a.sent();
                        featureDao = geopackage.getFeatureDao(table);
                        if (!featureDao)
                            throw new Error('Unable to find table ' + table);
                        bb = new boundingBox_1.BoundingBox(west, east, south, north);
                        iterator = featureDao.queryIndexedFeaturesWithBoundingBox(bb);
                        return [2 /*return*/, iterator];
                }
            });
        });
    };
    /**
     * Get the standard 3857 XYZ tile from the GeoPackage.  If a canvas is provided, the tile will be drawn in the canvas
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table containing the tiles
     * @param  {Number}   x          x index of the tile
     * @param  {Number}   y          y index of the tile
     * @param  {Number}   z          zoom level of the tile
     * @param  {Number}   width      width of the resulting tile
     * @param  {Number}   height     height of the resulting tile
     * @param  {any}   canvas     canvas element to draw the tile into
     */
    GeoPackageAPI.xyzTile = function (geopackage, table, x, y, z, width, height, canvas) {
        if (width === void 0) { width = 256; }
        if (height === void 0) { height = 256; }
        return __awaiter(this, void 0, void 0, function () {
            var tileDao, retriever;
            return __generator(this, function (_a) {
                width = Number(width);
                height = Number(height);
                tileDao = geopackage.getTileDao(table);
                retriever = new retriever_1.GeoPackageTileRetriever(tileDao, width, height);
                if (!canvas) {
                    return [2 /*return*/, retriever.getTile(x, y, z)];
                }
                else {
                    return [2 /*return*/, retriever.drawTileIn(x, y, z, canvas)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Draws a tile projected into the specified projection, bounded by the specified by the bounds in EPSG:4326 into the canvas or the image is returned if no canvas is passed in
     * @param  {module:geoPackage~GeoPackage}   geopackage open GeoPackage object
     * @param  {string}   table      name of the table containing the tiles
     * @param  {Number}   minLat     minimum latitude bounds of tile
     * @param  {Number}   minLon     minimum longitude bounds of tile
     * @param  {Number}   maxLat     maximum latitude bounds of tile
     * @param  {Number}   maxLon     maximum longitude bounds of tile
     * @param  {Number}   z          zoom level of the tile
     * @param  {Number}   width      width of the resulting tile
     * @param  {Number}   height     height of the resulting tile
     * @param  {any}   canvas     canvas element to draw the tile into
     */
    GeoPackageAPI.projectedTile = function (geopackage, table, minLat, minLon, maxLat, maxLon, z, projection, width, height, canvas) {
        if (width === void 0) { width = 256; }
        if (height === void 0) { height = 256; }
        return __awaiter(this, void 0, void 0, function () {
            var tileDao, retriever, bounds;
            return __generator(this, function (_a) {
                tileDao = geopackage.getTileDao(table);
                retriever = new retriever_1.GeoPackageTileRetriever(tileDao, width, height);
                bounds = new boundingBox_1.BoundingBox(minLon, maxLon, minLat, maxLat);
                return [2 /*return*/, retriever.getTileWithWgs84BoundsInProjection(bounds, z, projection, canvas)];
            });
        });
    };
    GeoPackageAPI.version = '3.0.0';
    return GeoPackageAPI;
}());
exports.GeoPackageAPI = GeoPackageAPI;
//# sourceMappingURL=api.js.map